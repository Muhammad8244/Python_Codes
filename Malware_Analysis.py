from PyQt5.QtWidgets import (
    QApplication, QMainWindow, QVBoxLayout, QHBoxLayout, QWidget, QPushButton, QLabel, QFileDialog, QTabWidget,
    QTextEdit, QTreeWidget, QTreeWidgetItem, QProgressBar, QTableWidget, QTableWidgetItem, QHeaderView, QSplitter,
    QMessageBox, QGroupBox, QCheckBox, QGridLayout, QScrollArea, QLineEdit, QComboBox, QToolBar, QAction, QMenu, QDialog,
    QFormLayout, QSpinBox, QListWidget
)
import sys
import os
import pefile
import hashlib
import subprocess
import re
import json
import magic
import time
from collections import Counter
import math
import threading
from datetime import datetime
## (Removed duplicate multi-line import of PyQt5.QtWidgets)
from PyQt5.QtCore import Qt, QThread, pyqtSignal, QSize, QTimer
from PyQt5.QtGui import QIcon, QFont, QColor, QTextCharFormat, QBrush, QPalette, QPainter, QPen,QPixmap


class MalwareAnalyzer:
    def __init__(self, file_path):
        self.file_path = file_path
        self.pe = None
        self.results = {
            "basic_info": {},
            "hash_values": {},
            "headers": {},
            "sections": [],
            "imports": {},
            "exports": [],
            "strings": [],
            "packer_detection": {},
            "suspicious_indicators": [],
            "analysis_timeline": [],
            "network_activity": [],
            "entry_point": {},
            "signatures": {},
            "file_access": {"ascii": [], "unicode": []},
            "anti_vm_sandbox": [],
            "urls": [],
            "payloads": [],
            "ip_addresses": [],
            "intelligent_strings": [],
            "extra_analysis": {},
            "threat_score": 0
        }
        self.progress_callback = None
        self.status_callback = None
        self.custom_rules = []
        self.initial_hash = None

    def set_callbacks(self, progress_callback, status_callback):
        self.progress_callback = progress_callback
        self.status_callback = status_callback

    def set_custom_rules(self, rules):
        self.custom_rules = rules

    def update_progress(self, value, message):
        if self.progress_callback:
            self.progress_callback(value, message)

    def update_status(self, message):
        if self.status_callback:
            self.status_callback(message)

    def add_to_timeline(self, step, details):
        self.results["analysis_timeline"].append({
            "timestamp": datetime.now().isoformat(),
            "step": step,
            "details": details
        })

    def basic_file_info(self):
        try:
            file_size = os.path.getsize(self.file_path)
            file_type = magic.from_file(self.file_path)
            imphash = ""
            architecture = ""
            aslr_enabled = False
            if self.pe:
                imphash = self.pe.get_imphash()
                machine = self.pe.FILE_HEADER.Machine
                architecture = "x64" if machine == 0x8664 else "x86" if machine == 0x14c else "Unknown"
                if hasattr(self.pe, 'OPTIONAL_HEADER'):
                    dll_characteristics = self.pe.OPTIONAL_HEADER.DllCharacteristics
                    aslr_enabled = (dll_characteristics & 0x0040) != 0  # IMAGE_DLLCHARACTERISTICS_DYNAMIC_BASE
            self.results["basic_info"] = {
                "file_name": os.path.basename(self.file_path),
                "file_size": file_size,
                "file_size_readable": self._format_size(file_size),
                "file_type": file_type,
                "creation_time": datetime.fromtimestamp(os.path.getctime(self.file_path)).isoformat(),
                "modification_time": datetime.fromtimestamp(os.path.getmtime(self.file_path)).isoformat(),
                "imphash": imphash,
                "architecture": architecture,
                "aslr": "Enabled" if aslr_enabled else "Disabled",
                "major_os_version": self.pe.OPTIONAL_HEADER.MajorOperatingSystemVersion if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else 0,
                "check_sum": hex(self.pe.OPTIONAL_HEADER.CheckSum) if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else "0x0",
                "size_of_headers": self.pe.OPTIONAL_HEADER.SizeOfHeaders if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else 0,
                "size_of_image": hex(self.pe.OPTIONAL_HEADER.SizeOfImage) if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else "0x0",
                "image_base": hex(self.pe.OPTIONAL_HEADER.ImageBase) if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else "0x0",
                "import_table": hex(self.pe.OPTIONAL_HEADER.DATA_DIRECTORY[1].VirtualAddress) if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else "0x0",
                "subsystem": self.pe.OPTIONAL_HEADER.Subsystem if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else 0,
                "subsystem_readable": pefile.SUBSYSTEM_TYPE.get(self.pe.OPTIONAL_HEADER.Subsystem, "Unknown") if self.pe and hasattr(self.pe, 'OPTIONAL_HEADER') else "Unknown",
                "number_of_sections": self.pe.FILE_HEADER.NumberOfSections if self.pe else 0,
                "section_names": [section.Name.decode('utf-8', 'ignore').strip('\x00') for section in self.pe.sections] if self.pe else [],
                "number_of_executable_sections": sum(1 for section in self.pe.sections if section.Characteristics & 0x20000000) if self.pe else 0
            }
            self.add_to_timeline("Basic Info", "Collected basic file information")
        except Exception as e:
            self.update_status(f"Error getting basic file info: {str(e)}")
            self.results["basic_info"] = {"error": str(e)}

    def _format_size(self, size):
        for unit in ['bytes', 'KB', 'MB', 'GB', 'TB']:
            if size < 1024:
                return f"{size:.2f} {unit}"
            size /= 1024.0
        return f"{size:.2f} PB"

    def calculate_hashes(self):
        try:
            with open(self.file_path, 'rb') as f:
                data = f.read()
            self.results["hash_values"] = {
                "md5": hashlib.md5(data).hexdigest(),
                "sha1": hashlib.sha1(data).hexdigest(),
                "sha256": hashlib.sha256(data).hexdigest(),
                "sha512": hashlib.sha512(data).hexdigest()
            }
            self.initial_hash = self.results["hash_values"]["sha256"]
            self.add_to_timeline("Hash Calculation", "Computed file hashes")
        except Exception as e:
            self.update_status(f"Error calculating hashes: {str(e)}")
            self.results["hash_values"] = {"error": str(e)}

    def check_file_changes(self):
        try:
            with open(self.file_path, 'rb') as f:
                data = f.read()
                current_hash = hashlib.sha256(data).hexdigest()
            if current_hash != self.initial_hash:
                self.update_status("Warning: File content has changed during analysis!")
                self.add_to_timeline("File Change", "Detected file modification")
                return True
            return False
        except Exception as e:
            self.update_status(f"Error checking file changes: {str(e)}")
            return False

    def analyze_network_activity(self):
        try:
            network_indicators = []
            network_functions = ["socket", "connect", "send", "recv", "InternetOpen", "HttpSendRequest",
                                 "bind", "listen", "accept", "WSACleanup"]
            for dll, functions in self.results["imports"].items():
                if isinstance(functions, list):
                    for func in functions:
                        func_name = func.get("name", "").lower()
                        if any(nf.lower() in func_name for nf in network_functions):
                            network_indicators.append({
                                "dll": dll,
                                "function": func_name,
                                "address": func.get("address", "N/A"),
                                "description": self._get_function_description(func_name)
                            })
            self.results["network_activity"] = network_indicators
            self.add_to_timeline("Network Analysis", f"Found {len(network_indicators)} network-related functions")
        except Exception as e:
            self.update_status(f"Error analyzing network activity: {str(e)}")
            self.results["network_activity"] = [{"error": str(e)}]

    def _get_function_description(self, func_name):
        descriptions = {
            "virtualalloc": "Reserve, commit, or both, a region of memory within the virtual address space of a process.",
            "writefile": "Writes data to a specified file or input/output (I/O) device.",
            "loadlibraryw": "Loads the specified module into the address space of the calling process.",
            "getprocaddress": "Retrieves the address of an exported function or variable from the specified dynamic-link library (DLL).",
            "socket": "Create a communication endpoint for networking applications.",
            "bind": "Associates a socket with a local address.",
            "listen": "Places a socket in a state in which it is listening for an incoming connection.",
            "accept": "Permits an incoming connection attempt on a socket.",
            "connect": "Establishes a connection to a specified socket.",
            "recv": "Receives data from a connected socket.",
            "send": "Sends data on a connected socket.",
            "wsacleanup": "Terminates use of the Winsock 2 DLL (Ws2_32.dll).",
            "regcreatekeyex": "Creates the specified registry key.",
            "regopenkeyex": "Opens the specified registry key.",
            "regsetvalueex": "Sets the data and type of a specified value under a registry key.",
            "gettemppath": "Retrieves the path of the directory designated for temporary files.",
            "createfile": "Creates or opens a file or I/O device.",
            "readfile": "Reads data from the specified file or input/output (I/O) device.",
            "openscmanager": "Establishes a connection to the service control manager.",
            "cryptacquirecontext": "Acquires a handle to a particular key container within a cryptographic service provider (CSP).",
            "cryptreleasecontext": "Releases the handle acquired by CryptAcquireContext.",
            "getsysteminfo": "Retrieves information about the current system.",
            "getversion": "Retrieves the version of the operating system.",
            "createtoolhelp32snapshot": "Takes a snapshot of the specified processes, as well as the heaps, modules, and threads used by these processes."
        }
        return descriptions.get(func_name.lower(), "No description available.")

    def calculate_threat_score(self):
        score = 0
        if self.results["packer_detection"].get("is_packed", False):
            score += 30
        score += len(self.results["suspicious_indicators"]) * 5
        suspicious_imports = sum(sum(1 for f in functions if f.get("suspicious", False)) 
                               for dll, functions in self.results["imports"].items() if isinstance(functions, list))
        score += suspicious_imports * 3
        suspicious_strings = sum(1 for s in self.results["strings"] if s.get("suspicious", False))
        score += suspicious_strings * 2
        score += len(self.results["network_activity"]) * 5
        score += len(self.results["anti_vm_sandbox"]) * 10
        score += len(self.results["urls"]) * 8
        score += len(self.results["payloads"]) * 15
        score += len(self.results["ip_addresses"]) * 8
        if not self.results["signatures"].get("is_signed", False):
            score += 10
        self.results["threat_score"] = min(score, 100)

    def analyze(self):
        if not os.path.exists(self.file_path):
            self.update_status("File not found!")
            return False
        
        self.update_status(f"Starting analysis of {os.path.basename(self.file_path)}")
        self.update_progress(0, "Initializing analysis...")
        
        self.update_progress(10, "Gathering basic file information...")
        self.basic_file_info()
        
        self.update_progress(20, "Calculating file hashes...")
        self.calculate_hashes()
        
        try:
            self.pe = pefile.PE(self.file_path, fast_load=True)
        except pefile.PEFormatError:
            self.update_status("Not a valid PE file. Limited analysis available.")
            self.extract_strings()
            self.analyze_file_access()
            self.analyze_urls_and_ips()
            self.analyze_extra()
            return self.results
        except Exception as e:
            self.update_status(f"Error parsing PE file: {str(e)}. Limited analysis available.")
            self.extract_strings()
            self.analyze_file_access()
            self.analyze_urls_and_ips()
            self.analyze_extra()
            return self.results
                
        try:
            self.update_progress(30, "Analyzing PE headers...")
            self.analyze_headers()
        except Exception as e:
            self.update_status(f"Error analyzing headers: {str(e)}")
        
        try:
            self.update_progress(40, "Analyzing file sections...")
            self.analyze_sections()
        except Exception as e:
            self.update_status(f"Error analyzing sections: {str(e)}")
        
        try:
            self.update_progress(50, "Analyzing imports...")
            self.analyze_imports()
        except Exception as e:
            self.update_status(f"Error analyzing imports: {str(e)}")
        
        try:
            self.update_progress(60, "Analyzing exports...")
            self.analyze_exports()
        except Exception as e:
            self.update_status(f"Error analyzing exports: {str(e)}")
        
        try:
            self.update_progress(70, "Extracting strings...")
            self.extract_strings()
        except Exception as e:
            self.update_status(f"Error extracting strings: {str(e)}")
        
        try:
            self.update_progress(80, "Detecting packers...")
            self.detect_packers()
        except Exception as e:
            self.update_status(f"Error detecting packers: {str(e)}")
        
        try:
            self.update_progress(85, "Analyzing network activity...")
            self.analyze_network_activity()
        except Exception as e:
            self.update_status(f"Error analyzing network activity: {str(e)}")
        
        try:
            self.update_progress(87, "Analyzing entry point...")
            self.analyze_entry_point()
        except Exception as e:
            self.update_status(f"Error analyzing entry point: {str(e)}")
        
        try:
            self.update_progress(89, "Checking signatures...")
            self.analyze_signatures()
        except Exception as e:
            self.update_status(f"Error checking signatures: {str(e)}")
        
        try:
            self.update_progress(91, "Analyzing file access...")
            self.analyze_file_access()
        except Exception as e:
            self.update_status(f"Error analyzing file access: {str(e)}")
        
        try:
            self.update_progress(93, "Detecting anti-VM/sandbox tricks...")
            self.analyze_anti_vm_sandbox()
        except Exception as e:
            self.update_status(f"Error detecting anti-VM/sandbox tricks: {str(e)}")
        
        try:
            self.update_progress(95, "Analyzing URLs and IPs...")
            self.analyze_urls_and_ips()
        except Exception as e:
            self.update_status(f"Error analyzing URLs and IPs: {str(e)}")
        
        try:
            self.update_progress(97, "Analyzing payloads...")
            self.analyze_payloads()
        except Exception as e:
            self.update_status(f"Error analyzing payloads: {str(e)}")
        
        try:
            self.update_progress(98, "Performing extra analysis...")
            self.analyze_extra()
        except Exception as e:
            self.update_status(f"Error performing extra analysis: {str(e)}")
        
        try:
            self.update_progress(99, "Finding suspicious indicators...")
            self.find_suspicious_indicators()
        except Exception as e:
            self.update_status(f"Error finding suspicious indicators: {str(e)}")
        
        try:
            self.update_progress(100, "Calculating threat score...")
            self.calculate_threat_score()
        except Exception as e:
            self.update_status(f"Error calculating threat score: {str(e)}")
        
        self.update_progress(100, "Analysis complete!")
        self.update_status("Analysis completed successfully")
        return self.results
    
    def analyze_headers(self):
        if not self.pe:
            self.update_status("No PE file loaded for header analysis.")
            self.results["headers"] = {"error": "No PE file loaded"}
            return
        try:
            self.results["headers"]["dos_header"] = {
                "e_magic": hex(self.pe.DOS_HEADER.e_magic),
                "e_lfanew": hex(self.pe.DOS_HEADER.e_lfanew)
            }
            self.results["headers"]["file_header"] = {
                "Machine": hex(self.pe.FILE_HEADER.Machine),
                "NumberOfSections": self.pe.FILE_HEADER.NumberOfSections,
                "TimeDateStamp": self.pe.FILE_HEADER.TimeDateStamp,
                "TimeDateStamp_readable": self.pe.FILE_HEADER.get_timestamp_str(),
                "Characteristics": hex(self.pe.FILE_HEADER.Characteristics),
                "Characteristics_flags": pefile.retrieve_flags(pefile.IMAGE_CHARACTERISTICS, self.pe.FILE_HEADER.Characteristics)
            }
            if hasattr(self.pe, 'OPTIONAL_HEADER'):
                self.results["headers"]["optional_header"] = {
                    "Magic": hex(self.pe.OPTIONAL_HEADER.Magic),
                    "MajorLinkerVersion": self.pe.OPTIONAL_HEADER.MajorLinkerVersion,
                    "MinorLinkerVersion": self.pe.OPTIONAL_HEADER.MinorLinkerVersion,
                    "SizeOfCode": self.pe.OPTIONAL_HEADER.SizeOfCode,
                    "AddressOfEntryPoint": hex(self.pe.OPTIONAL_HEADER.AddressOfEntryPoint),
                    "ImageBase": hex(self.pe.OPTIONAL_HEADER.ImageBase),
                    "SectionAlignment": self.pe.OPTIONAL_HEADER.SectionAlignment,
                    "FileAlignment": self.pe.OPTIONAL_HEADER.FileAlignment,
                    "MajorOperatingSystemVersion": self.pe.OPTIONAL_HEADER.MajorOperatingSystemVersion,
                    "MinorOperatingSystemVersion": self.pe.OPTIONAL_HEADER.MinorOperatingSystemVersion,
                    "MajorImageVersion": self.pe.OPTIONAL_HEADER.MajorImageVersion,
                    "MinorImageVersion": self.pe.OPTIONAL_HEADER.MinorImageVersion,
                    "MajorSubsystemVersion": self.pe.OPTIONAL_HEADER.MajorSubsystemVersion,
                    "MinorSubsystemVersion": self.pe.OPTIONAL_HEADER.MinorSubsystemVersion,
                    "SizeOfHeaders": self.pe.OPTIONAL_HEADER.SizeOfHeaders,
                    "Subsystem": self.pe.OPTIONAL_HEADER.Subsystem,
                    "DllCharacteristics": hex(self.pe.OPTIONAL_HEADER.DllCharacteristics),
                    "DllCharacteristics_flags": pefile.retrieve_flags(pefile.DLL_CHARACTERISTICS, self.pe.OPTIONAL_HEADER.DllCharacteristics)
                }
            self.add_to_timeline("Headers Analysis", "Analyzed PE headers")
        except Exception as e:
            self.update_status(f"Error analyzing headers: {str(e)}")
            self.results["headers"] = {"error": str(e)}
    
    def analyze_sections(self):
        if not self.pe:
            self.update_status("No PE file loaded for section analysis.")
            self.results["sections"] = [{"error": "No PE file loaded"}]
            return
        try:
            suspicious_sections = [".ndata", ".packed", ".protect", "UPX", ".vmp", "/4", "/19", "/32", "/46", "/65", "/78", "/90"]
            high_entropy_threshold = 7.0
            self.results["sections"].clear()
            for section in self.pe.sections:
                section_name = section.Name.decode('utf-8', 'ignore').strip('\x00')
                flags = pefile.retrieve_flags(pefile.SECTION_CHARACTERISTICS, section.Characteristics)
                section_info = {
                    "Name": section_name,
                    "VirtualAddress": hex(section.VirtualAddress),
                    "VirtualSize": section.Misc_VirtualSize,
                    "RawAddress": hex(section.PointerToRawData),
                    "RawSize": section.SizeOfRawData,
                    "Entropy": section.get_entropy(),
                    "Flags": hex(section.Characteristics),
                    "Flags_readable": flags,
                    "VirtualOffset": hex(section.VirtualAddress),
                    "Suspicious": False,
                    "Reason": []
                }
                if section_info["Entropy"] > high_entropy_threshold:
                    section_info["Suspicious"] = True
                    section_info["Reason"].append(f"High entropy ({section_info['Entropy']:.2f})")
                for sus_name in suspicious_sections:
                    if sus_name.lower() in section_name.lower():
                        section_info["Suspicious"] = True
                        section_info["Reason"].append(f"Suspicious name ({sus_name})")
                if "IMAGE_SCN_MEM_EXECUTE" in flags and "IMAGE_SCN_MEM_WRITE" in flags:
                    section_info["Suspicious"] = True
                    section_info["Reason"].append("Section is executable and writable")
                self.results["sections"].append(section_info)
            self.update_status(f"Analyzed {len(self.results['sections'])} sections.")
            self.add_to_timeline("Sections Analysis", f"Analyzed {len(self.results['sections'])} PE sections")
        except Exception as e:
            self.update_status(f"Error analyzing sections: {str(e)}")
            self.results["sections"] = [{"error": str(e)}]
    
    def analyze_imports(self):
        if not self.pe:
            self.update_status("No PE file loaded for import analysis.")
            self.results["imports"] = {"error": "No PE file loaded"}
            return
        try:
            suspicious_imports = {
                "kernel32.dll": ["CreateRemoteThread", "VirtualAllocEx", "WriteProcessMemory", 
                                "ReadProcessMemory", "CreateProcess", "WinExec", "ShellExecute",
                                "VirtualAlloc", "WriteFile", "LoadLibraryW", "GetProcAddress",
                                "CreateProcessA", "CreateProcessW", "ResumeThread", "GetTempPathW",
                                "CreateFileW", "ReadFile", "OpenSCManagerW", "GetSystemInfo",
                                "GetVersion", "CreateToolhelp32Snapshot"],
                "user32.dll": ["FindWindow", "SetWindowsHookEx", "RegisterHotKey"],
                "wininet.dll": ["InternetOpen", "InternetConnect", "HttpOpenRequest"],
                "advapi32.dll": ["RegOpenKey", "RegSetValue", "CryptEncrypt", "RegCreateKeyExW",
                                 "RegOpenKeyExW", "RegSetValueExW", "CryptAcquireContextW",
                                 "CryptReleaseContext"],
                "ws2_32.dll": ["socket", "connect", "recv", "send", "bind", "listen", "accept", "WSACleanup"]
            }
            self.results["imports"].clear()
            if hasattr(self.pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode('utf-8').lower()
                    self.results["imports"][dll_name] = []
                    for imp in entry.imports:
                        func_name = imp.name.decode('utf-8') if imp.name else f"ord_{imp.ordinal}"
                        is_suspicious = False
                        description = self._get_function_description(func_name.lower())
                        if dll_name in suspicious_imports and func_name in suspicious_imports[dll_name]:
                            is_suspicious = True
                        self.results["imports"][dll_name].append({
                            "name": func_name,
                            "address": hex(imp.address),
                            "suspicious": is_suspicious,
                            "description": description
                        })
            else:
                self.results["imports"] = {"info": "No import directory found"}
            self.add_to_timeline("Imports Analysis", "Analyzed imported functions")
        except Exception as e:
            self.update_status(f"Error analyzing imports: {str(e)}")
            self.results["imports"] = {"error": str(e)}
    
    def analyze_exports(self):
        if not self.pe:
            self.update_status("No PE file loaded for export analysis.")
            self.results["exports"] = [{"error": "No PE file loaded"}]
            return
        try:
            self.results["exports"].clear()
            if hasattr(self.pe, 'DIRECTORY_ENTRY_EXPORT'):
                for exp in self.pe.DIRECTORY_ENTRY_EXPORT.symbols:
                    export_info = {
                        "ordinal": exp.ordinal,
                        "name": exp.name.decode('utf-8') if exp.name else "",
                        "address": hex(exp.address)
                    }
                    self.results["exports"].append(export_info)
            else:
                self.results["exports"] = [{"info": "No export directory found"}]
            self.add_to_timeline("Exports Analysis", "Analyzed exported functions")
        except Exception as e:
            self.update_status(f"Error analyzing exports: {str(e)}")
            self.results["exports"] = [{"error": str(e)}]
    
    def extract_strings(self):
        try:
            with open(self.file_path, 'rb') as f:
                data = f.read()
            ascii_regex = re.compile(b'[\x20-\x7E]{4,}')
            ascii_strings = [s.decode('ascii') for s in ascii_regex.findall(data)]
            unicode_regex = re.compile(b'(?:[\x20-\x7E]\x00){4,}')
            unicode_strings = [s.decode('utf-16-le') for s in unicode_regex.findall(data)]
            all_strings = ascii_strings + unicode_strings
            self.results["strings"].clear()
            suspicious_keywords = [
                "cmd.exe", "powershell", "http://", "https://", "ftp://", 
                "CreateProcess", "VirtualAlloc", "WriteProcessMemory",
                "RegCreateKey", "RegSetValue", "WScript", "WSHShell",
                "RegCreateKeyEx", "RegOpenKeyEx", "RegSetValueEx",
                "GetTempPath", "CreateFile", "WriteFile", "ReadFile",
                "OpenSCManager", "CryptAcquireContext", "CryptReleaseContext",
                "GetSystemInfo", "GetVersion", "CreateToolhelp32Snapshot",
                "Logger", "zombie", "procexp"
            ]
            intelligent_strings = [
                "ntdll.dll", "winmm.dll", "powrprof.dll", "bcryptprimitives.dll",
                "kernel32.dll", "io.EOF"
            ]
            self.results["intelligent_strings"] = []
            for s in all_strings:
                s = s.strip()
                if len(s) >= 4:
                    is_suspicious = any(keyword.lower() in s.lower() for keyword in suspicious_keywords)
                    self.results["strings"].append({
                        "string": s,
                        "suspicious": is_suspicious
                    })
                    if any(keyword.lower() in s.lower() for keyword in intelligent_strings):
                        self.results["intelligent_strings"].append(s)
            self.results["strings"].sort(key=lambda x: (-int(x["suspicious"]), x["string"]))
            self.results["strings"] = self.results["strings"][:1000]
            self.add_to_timeline("Strings Extraction", "Extracted strings from file")
        except Exception as e:
            self.update_status(f"Error extracting strings: {str(e)}")
            self.results["strings"] = [{"error": str(e)}]
    
    def detect_packers(self):
        if not self.pe:
            self.update_status("No PE file loaded for packer detection.")
            self.results["packer_detection"] = {"error": "No PE file loaded"}
            return
        try:
            packers = {
                "UPX": ["UPX0", "UPX1", "UPX2", "UPX!"],
                "Themida": [".themida"],
                "VMProtect": [".vmp0", ".vmp1", ".vmp2"],
                "ASPack": [".aspack", "ASPack"],
                "Go": ["/4", "/19", "/32", "/46", "/65", "/78", "/90"]  # Go compiler sections
            }
            detected = []
            section_names = [section.Name.decode('utf-8', 'ignore').strip('\x00') for section in self.pe.sections]
            overall_entropy = self._calculate_file_entropy()
            for packer_name, signatures in packers.items():
                if any(sig in name for name in section_names for sig in signatures):
                    detected.append(packer_name)
            if hasattr(self.pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in self.pe.DIRECTORY_ENTRY_IMPORT:
                    if entry.dll.decode('utf-8').lower() == "upx.dll":
                        if "UPX" not in detected:
                            detected.append("UPX")
            compiler = "Go(1.15.0-X.XX.X)" if "Go" in detected else "Unknown"
            self.results["packer_detection"] = {
                "detected_packers": detected,
                "is_packed": len(detected) > 0,
                "compiler": compiler,
                "overall_entropy": overall_entropy
            }
            self.add_to_timeline("Packer Detection", f"Packers detected: {', '.join(detected) if detected else 'None'}")
        except Exception as e:
            self.update_status(f"Error detecting packers: {str(e)}")
            self.results["packer_detection"] = {"error": str(e)}

    def _calculate_file_entropy(self):
      try:
        with open(self.file_path, 'rb') as f:
            data = f.read()
        if not data:
            self.update_status("Error: Empty file for entropy calculation")
            return 0.0

        # Count frequency of each byte
        byte_counts = Counter(data)
        file_size = len(data)

        # Calculate entropy
        entropy = 0.0
        for count in byte_counts.values():
            probability = count / file_size
            entropy -= probability * math.log2(probability)

        return round(entropy, 5)
      except FileNotFoundError:
        self.update_status(f"Error: File not found: {self.file_path}")
        return 0.0
      except Exception as e:
        self.update_status(f"Error calculating entropy: {str(e)}")
        return 0.0

    def analyze_entry_point(self):
        if not self.pe:
            self.update_status("No PE file loaded for entry point analysis.")
            self.results["entry_point"] = {"error": "No PE file loaded"}
            return
        try:
            ep_rva = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
            section_number = None
            calculated_ep = None
            code_bytes = ""
            instructions = []
            for idx, section in self.pe.sections:
                if section.VirtualAddress <= ep_rva < section.VirtualAddress + section.Misc_VirtualSize:
                    section_number = idx + 1
                    calculated_ep = hex(ep_rva - section.VirtualAddress + section.PointerToRawData)
                    try:
                        data = self.pe.get_data(ep_rva, 64)
                        code_bytes = data.hex().upper()
                        instructions = self._disassemble_entry_point(data)
                    except:
                        code_bytes = "Unable to read"
                        instructions = ["Error reading code"]
                    break
            self.results["entry_point"] = {
                "section_number": section_number,
                "entry_point_rva": hex(ep_rva),
                "calculated_entry_point": calculated_ep,
                "code_bytes": code_bytes,
                "instructions": instructions
            }
            self.add_to_timeline("Entry Point Analysis", "Analyzed entry point code")
        except Exception as e:
            self.update_status(f"Error analyzing entry point: {str(e)}")
            self.results["entry_point"] = {"error": str(e)}

    def _disassemble_entry_point(self, data):
        # Simple disassembly simulation for demonstration
        # In a real tool, use a disassembler like capstone
        instructions = []
        if len(data) < 2:
            return ["No code to disassemble"]
        if data[:2] == b'\xE9\x3B':  # JMP
            instructions.append("JMP 0xFFFFFFFFFFFFD740")
        for b in data[2:10]:
            if b == 0xCC:
                instructions.append("INT3")
        if len(data) > 10 and data[10:12] == b'\x55\x48':
            instructions.append("PUSH RBP")
            instructions.append("MOV RBP, RSP")
        if len(data) > 12 and data[12] == 0x9C:
            instructions.append("PUSHFQ")
        if len(data) > 13 and data[13] == 0xFC:
            instructions.append("CLD")
        if len(data) > 14 and data[14:18] == b'\x48\x81\xEC\xE0':
            instructions.append("SUB RSP, 0xE0")
        if len(data) > 18 and data[18:22] == b'\x48\x89\x3C\x24':
            instructions.append("MOV QWORD PTR [RSP], RDI")
        return instructions[:10]  # Limit for brevity

    def analyze_signatures(self):
        if not self.pe:
            self.update_status("No PE file loaded for signature analysis.")
            self.results["signatures"] = {"error": "No PE file loaded"}
            return
        try:
            is_signed = False
            if hasattr(self.pe, 'DIRECTORY_ENTRY_SECURITY'):
                is_signed = bool(self.pe.DIRECTORY_ENTRY_SECURITY)
            self.results["signatures"] = {
                "is_signed": is_signed,
                "status": "Digital Signature Found" if is_signed else "Digital Signature Not Found"
            }
            self.add_to_timeline("Signature Analysis", f"Signature status: {'Signed' if is_signed else 'Not Signed'}")
        except Exception as e:
            self.update_status(f"Error analyzing signatures: {str(e)}")
            self.results["signatures"] = {"error": str(e)}

    def analyze_file_access(self):
        try:
            file_access_ascii = []
            file_access_unicode = []
            access_keywords = [
                "runtime.exe", "os/exec.exe", "os.Exe", "internal/poll.exe", "powershell.exe",
                "syscall.DLL", "kernel32.dll", "bcryptprimitives.dll", "ntdll.dll", "winmm.dll",
                "advapi32.dll", "iphlpapi.dll", "netapi32.dll", "crypt32.dll", "mswsock.dll",
                "secur32.dll", "shell32.dll", "userenv.dll", "dnsapi.dll", "ws2_32.dll",
                "psapi.dll", "powrprof.dll", ".bat", ".ini", "Temp", "SysDir", "UserProfile"
            ]
            unicode_dlls = ["ntdll.dll", "winmm.dll", "powrprof.dll", "bcryptprimitives.dll"]
            for s in self.results["strings"]:
                string_val = s.get("string", "")
                for keyword in access_keywords:
                    if keyword.lower() in string_val.lower():
                        file_access_ascii.append(string_val)
                        break
                for dll in unicode_dlls:
                    if dll.lower() in string_val.lower() and string_val.endswith(".dll"):
                        file_access_unicode.append(string_val)
            self.results["file_access"] = {
                "ascii": list(set(file_access_ascii)),
                "unicode": list(set(file_access_unicode))
            }
            self.add_to_timeline("File Access Analysis", f"Found {len(file_access_ascii)} ASCII and {len(file_access_unicode)} Unicode file access strings")
        except Exception as e:
            self.update_status(f"Error analyzing file access: {str(e)}")
            self.results["file_access"] = {"error": str(e)}

    def analyze_anti_vm_sandbox(self):
        try:
            anti_vm_tricks = []
            anti_vm_keywords = ["procexp", "GetSystemInfo", "GetVersion", "CreateToolhelp32Snapshot"]
            for s in self.results["strings"]:
                if any(keyword.lower() in s.get("string", "").lower() for keyword in anti_vm_keywords):
                    anti_vm_tricks.append(s["string"])
            for dll, functions in self.results["imports"].items():
                if isinstance(functions, list):
                    for func in functions:
                        if any(keyword.lower() in func.get("name", "").lower() for keyword in anti_vm_keywords):
                            anti_vm_tricks.append(f"{dll}:{func['name']}")
            self.results["anti_vm_sandbox"] = list(set(anti_vm_tricks))
            self.add_to_timeline("Anti-VM/Sandbox Analysis", f"Found {len(anti_vm_tricks)} anti-VM/sandbox indicators")
        except Exception as e:
            self.update_status(f"Error analyzing anti-VM/sandbox tricks: {str(e)}")
            self.results["anti_vm_sandbox"] = ["Error: " + str(e)]

    def analyze_urls_and_ips(self):
        try:
            url_regex = re.compile(r'http[s]?://(?:[a-zA-Z]|[0-9]|[$-_@.&+]|[!*\\(\\),]|(?:%[0-9a-fA-F][0-9a-fA-F]))+')
            ip_regex = re.compile(r'\b(?:\d{1,3}\.){3}\d{1,3}\b')
            urls = []
            ip_addresses = []
            for s in self.results["strings"]:
                string_val = s.get("string", "")
                found_urls = url_regex.findall(string_val)
                found_ips = ip_regex.findall(string_val)
                urls.extend(found_urls)
                ip_addresses.extend(found_ips)
            self.results["urls"] = list(set(urls))
            self.results["ip_addresses"] = list(set(ip_addresses))
            self.add_to_timeline("URLs and IPs Analysis", f"Found {len(urls)} URLs and {len(ip_addresses)} IP addresses")
        except Exception as e:
            self.update_status(f"Error analyzing URLs and IPs: {str(e)}")
            self.results["urls"] = ["Error: " + str(e)]
            self.results["ip_addresses"] = ["Error: " + str(e)]

    def analyze_payloads(self):
        try:
            payloads = []
            nop_cave = b'\x90\x90\x90\x90\x90'
            bp_cave = b'\xCC\xCC\xCC\xCC\xCC'
            with open(self.file_path, 'rb') as f:
                data = f.read()
            if bp_cave in data:
                payloads.append(f"Unusual BP Cave > 15 Bytes - (0x{data[data.index(bp_cave):data.index(bp_cave)+16].hex().upper()})")
            if nop_cave in data:
                payloads.append(f"NOP Cave Found - (0x{nop_cave.hex().upper()})")
            self.results["payloads"] = payloads
            self.add_to_timeline("Payload Analysis", f"Found {len(payloads)} payloads")
        except Exception as e:
            self.update_status(f"Error analyzing payloads: {str(e)}")
            self.results["payloads"] = ["Error: " + str(e)]

    def analyze_extra(self):
        try:
            with open(self.file_path, 'rb') as f:
                data = f.read()
            total_bytes = len(data)
            ascii_count = sum(1 for b in data if 0x20 <= b <= 0x7E)
            null_count = data.count(b'\x00')
            nop_cave = b'\x90\x90\x90\x90\x90'
            nop_count = sum(1 for i in range(len(data)-4) if data[i:i+5] == nop_cave)
            self.results["extra_analysis"] = {
                "ascii_count": ascii_count,
                "ascii_percentage": (ascii_count / total_bytes * 100) if total_bytes > 0 else 0,
                "null_count": null_count,
                "null_percentage": (null_count / total_bytes * 100) if total_bytes > 0 else 0,
                "nop_cave_count": nop_count,
                "nop_cave_percentage": (nop_count * 5 / total_bytes * 100) if total_bytes > 0 else 0
            }
            self.add_to_timeline("Extra Analysis", "Performed extra file analysis")
        except Exception as e:
            self.update_status(f"Error performing extra analysis: {str(e)}")
            self.results["extra_analysis"] = {"error": str(e)}

    def find_suspicious_indicators(self):
        if not self.pe:
            self.update_status("No PE file loaded for suspicious indicators analysis.")
            self.results["suspicious_indicators"] = ["No PE file loaded"]
            return
        try:
            self.results["suspicious_indicators"].clear()
            if self.pe.FILE_HEADER.TimeDateStamp == 0:
                self.results["suspicious_indicators"].append("Zero timestamp (common in packed files)")
            if hasattr(self.pe, 'DIRECTORY_ENTRY_TLS') and self.pe.DIRECTORY_ENTRY_TLS:
                tls_callbacks = self.pe.DIRECTORY_ENTRY_TLS.struct.AddressOfCallBacks
                if tls_callbacks:
                    self.results["suspicious_indicators"].append("Contains TLS callbacks (can be used to execute code before main entry point)")
            if hasattr(self.pe, 'DIRECTORY_ENTRY_RESOURCE'):
                for resource_type in self.pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    if hasattr(resource_type, 'directory'):
                        for resource_id in resource_type.directory.entries:
                            if hasattr(resource_id, 'directory'):
                                for resource_lang in resource_id.directory.entries:
                                    data_rva = resource_lang.data.struct.OffsetToData
                                    size = resource_lang.data.struct.Size
                                    if size > 1000:
                                        data = self.pe.get_memory_mapped_image()[data_rva:data_rva+size]
                                        if data[:2] == b'MZ':
                                            self.results["suspicious_indicators"].append(f"Resource contains potential embedded executable (size: {size} bytes)")
            for section in self.pe.sections:
                if section.SizeOfRawData == 0 and section.Misc_VirtualSize > 0:
                    self.results["suspicious_indicators"].append(f"Section {section.Name.decode('utf-8', 'ignore').strip()} has virtual size but no raw data")
                if section.Misc_VirtualSize > section.SizeOfRawData * 10 and section.SizeOfRawData > 0:
                    self.results["suspicious_indicators"].append(f"Section {section.Name.decode('utf-8', 'ignore').strip()} has virtual size much larger than raw size")
            for section in self.pe.sections:
                flags = pefile.retrieve_flags(pefile.SECTION_CHARACTERISTICS, section.Characteristics)
                if "IMAGE_SCN_MEM_EXECUTE" in flags and "IMAGE_SCN_MEM_WRITE" in flags:
                    self.results["suspicious_indicators"].append(f"Section {section.Name.decode('utf-8', 'ignore').strip()} is both executable and writable")
            ep = self.pe.OPTIONAL_HEADER.AddressOfEntryPoint
            ep_found = False
            for section in self.pe.sections:
                if section.VirtualAddress <= ep < section.VirtualAddress + section.Misc_VirtualSize:
                    ep_found = True
                    section_name = section.Name.decode('utf-8', 'ignore').strip('\x00')
                    if section_name not in ['.text', 'CODE', '.code']:
                        self.results["suspicious_indicators"].append(f"Entry point is in an unusual section: {section_name}")
            if not ep_found:
                self.results["suspicious_indicators"].append("Entry point not found in any section")
            if not self.results["signatures"].get("is_signed", False):
                self.results["suspicious_indicators"].append("No digital signature found")
            for url in self.results["urls"]:
                self.results["suspicious_indicators"].append(f"Suspicious URL found: {url}")
            for ip in self.results["ip_addresses"]:
                self.results["suspicious_indicators"].append(f"Suspicious IP address found: {ip}")
            for payload in self.results["payloads"]:
                self.results["suspicious_indicators"].append(f"Suspicious payload: {payload}")
            for rule in self.custom_rules:
                if rule["condition"](self.pe, self.results):
                    self.results["suspicious_indicators"].append(rule["description"])
            self.add_to_timeline("Suspicious Indicators", f"Found {len(self.results['suspicious_indicators'])} suspicious indicators")
        except Exception as e:
            self.update_status(f"Error finding suspicious indicators: {str(e)}")
            self.results["suspicious_indicators"] = [f"Error: {str(e)}"]

class AnalysisThread(QThread):
    progress_update = pyqtSignal(int, str)
    status_update = pyqtSignal(str) 
    analysis_complete = pyqtSignal(dict)
    analysis_error = pyqtSignal(str)
    file_changed = pyqtSignal()
    
    def __init__(self, file_path, custom_rules):
        super().__init__()
        self.file_path = file_path
        self.custom_rules = custom_rules
        self.analyzer = None
        self.monitoring = True
        
    def run(self):
        try:
            self.analyzer = MalwareAnalyzer(self.file_path)
            self.analyzer.set_callbacks(
                progress_callback=lambda value, message: self.progress_update.emit(value, message),
                status_callback=lambda message: self.status_update.emit(message)
            )
            self.analyzer.set_custom_rules(self.custom_rules)
            results = self.analyzer.analyze()
            self.analysis_complete.emit(results)
            while self.monitoring:
                if self.analyzer.check_file_changes():
                    self.file_changed.emit()
                time.sleep(5)
        except Exception as e:
            self.analysis_error.emit(str(e))
            
    def stop_monitoring(self):
        self.monitoring = False

class EntropyChart(QWidget):
    def __init__(self):
        super().__init__()
        self.sections = []
        self.setMinimumHeight(200)

    def set_sections(self, sections):
        self.sections = sections
        self.update()

    def paintEvent(self, event):
        painter = QPainter(self)
        painter.setRenderHint(QPainter.Antialiasing)

        if not self.sections:
            return

        width = self.width()
        height = self.height()
        margin = 20
        max_entropy = 8.0

        bar_width = (width - 2 * margin) // max(1, len(self.sections))
        max_bar_height = height - 2 * margin

        for i, section in enumerate(self.sections):
            entropy = section.get('Entropy', 0)
            bar_height = (entropy / max_entropy) * max_bar_height if max_entropy > 0 else 0
            x = margin + i * bar_width
            if section.get('Suspicious', False):
                painter.setBrush(QBrush(QColor("#FF6B6B")))
            else:
                painter.setBrush(QBrush(QColor("#4ECDC4")))
            painter.setPen(Qt.NoPen)
            painter.drawRect(int(x), int(height - margin - bar_height), int(bar_width - 5), int(bar_height))
            painter.setPen(Qt.black)
            painter.drawText(int(x), int(height - margin - bar_height - 10), f"{entropy:.2f}")

class CustomRuleDialog(QDialog):
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Add Custom Rule")
        self.setGeometry(100, 100, 400, 300)
        layout = QFormLayout()
        self.description_input = QLineEdit()
        self.entropy_threshold = QSpinBox()
        self.entropy_threshold.setRange(0, 8)
        self.entropy_threshold.setValue(7)
        self.section_name_input = QLineEdit()
        layout.addRow("Rule Description:", self.description_input)
        layout.addRow("Entropy Threshold:", self.entropy_threshold)
        layout.addRow("Section Name Contains:", self.section_name_input)
        buttons = QHBoxLayout()
        save_btn = QPushButton("Save")
        save_btn.clicked.connect(self.accept)
        cancel_btn = QPushButton("Cancel")
        cancel_btn.clicked.connect(self.reject)
        buttons.addWidget(save_btn)
        buttons.addWidget(cancel_btn)
        layout.addRow(buttons)
        self.setLayout(layout)

    def get_rule(self):
        return {
            "description": self.description_input.text(),
            "condition": lambda pe, results: any(
                section['Entropy'] > self.entropy_threshold.value() and 
                self.section_name_input.text().lower() in section['Name'].lower()
                for section in results['sections']
            )
        }

class MalwareAnalysisGUI(QMainWindow):
    def show_analysis_summaries(self, results):
        # Show ML family classification
        try:
            fam, prob, risk = self.ai_classify_malware(results)
            if fam:
                self.show_text_dialog("ML Family Classification", f"Predicted Family: {fam}\nProbability: {prob:.2f}\nRisk Level: {risk}")
        except Exception as e:
            self.show_text_dialog("ML Family Classification", f"Classification error: {e}")
        # Show obfuscation detection
        try:
            findings = self.detect_obfuscation(results)
            if findings:
                self.show_text_dialog("Obfuscation Detection", '\n'.join(findings))
        except Exception as e:
            self.show_text_dialog("Obfuscation Detection", f"Obfuscation detection error: {e}")
        # Show IOC hits
        try:
            hits = self.check_iocs(results)
            if hits:
                import json
                self.show_text_dialog("IOC Hits", json.dumps(hits, indent=2))
        except Exception as e:
            self.show_text_dialog("IOC Hits", f"IOC check error: {e}")
        # Show config extraction
        try:
            pe = getattr(self, 'pe', None)
            configs = self.extract_config_with_plugins(pe, results)
            if configs:
                import json
                self.show_text_dialog("Config Extraction", json.dumps(configs, indent=2))
        except Exception as e:
            self.show_text_dialog("Config Extraction", f"Config extraction error: {e}")

    def show_text_dialog(self, title, text):
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton
        dlg = QDialog(self)
        dlg.setWindowTitle(title)
        layout = QVBoxLayout()
        edit = QTextEdit()
        edit.setReadOnly(True)
        edit.setPlainText(text)
        layout.addWidget(edit)
        btn = QPushButton("Close")
        btn.clicked.connect(dlg.accept)
        layout.addWidget(btn)
        dlg.setLayout(layout)
        dlg.resize(600, 400)
        dlg.exec_()
    def add_advanced_analysis_menu(self):
        from PyQt5.QtWidgets import QMenuBar, QAction, QMenu, QMessageBox, QFileDialog, QTextEdit, QDialog, QVBoxLayout, QPushButton
        import json
        menubar = self.menuBar() if hasattr(self, 'menuBar') else self.setMenuBar(QMenuBar(self)) or self.menuBar()
        adv_menu = menubar.addMenu("Advanced Analysis")

        def show_text_dialog(title, text):
            dlg = QDialog(self)
            dlg.setWindowTitle(title)
            layout = QVBoxLayout()
            edit = QTextEdit()
            edit.setReadOnly(True)
            edit.setPlainText(text)
            layout.addWidget(edit)
            btn = QPushButton("Close")
            btn.clicked.connect(dlg.accept)
            layout.addWidget(btn)
            dlg.setLayout(layout)
            dlg.resize(600, 400)
            dlg.exec_()

        def run_family_classification():
            if not self.current_results:
                QMessageBox.warning(self, "No Analysis", "No analysis results loaded.")
                return
            try:
                fam, prob, risk = self.ai_classify_malware(self.current_results[-1])
                if fam:
                    msg = f"Predicted Family: {fam}\nProbability: {prob:.2f}\nRisk Level: {risk}"
                else:
                    msg = "Classification not available."
                show_text_dialog("ML Family Classification", msg)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Classification error: {e}")

        def run_obfuscation_detection():
            if not self.current_results:
                QMessageBox.warning(self, "No Analysis", "No analysis results loaded.")
                return
            try:
                findings = self.detect_obfuscation(self.current_results[-1])
                msg = '\n'.join(findings) if findings else "No obfuscation detected."
                show_text_dialog("Obfuscation Detection", msg)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Obfuscation detection error: {e}")

        def run_ioc_export():
            if not self.current_results:
                QMessageBox.warning(self, "No Analysis", "No analysis results loaded.")
                return
            try:
                fmt, _ = QFileDialog.getSaveFileName(self, "Export IOCs", "ioc_report.json", "JSON Files (*.json);;CSV Files (*.csv)")
                if not fmt:
                    return
                ext = fmt.split('.')[-1].lower()
                data = self.export_ioc_report(self.current_results[-1], fmt='csv' if ext == 'csv' else 'json')
                with open(fmt, 'w', encoding='utf-8') as f:
                    f.write(data)
                QMessageBox.information(self, "Export Complete", f"IOC report saved to: {fmt}")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"IOC export error: {e}")

        def run_config_extract():
            if not self.current_results:
                QMessageBox.warning(self, "No Analysis", "No analysis results loaded.")
                return
            try:
                # Try to get PE object if available, else pass None
                pe = getattr(self, 'pe', None)
                configs = self.extract_config_with_plugins(pe, self.current_results[-1])
                msg = json.dumps(configs, indent=2) if configs else "No config extracted."
                show_text_dialog("Config Extraction", msg)
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Config extraction error: {e}")

        def run_plugin_reload():
            try:
                self.load_plugins()
                QMessageBox.information(self, "Plugins Reloaded", "Plugins reloaded successfully.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Plugin reload error: {e}")

        adv_menu.addAction(QAction("ML Family Classification", self, triggered=run_family_classification))
        adv_menu.addAction(QAction("Obfuscation Detection", self, triggered=run_obfuscation_detection))
        adv_menu.addAction(QAction("Export IOCs (CSV/JSON)", self, triggered=run_ioc_export))
        adv_menu.addAction(QAction("Extract Config with Plugins", self, triggered=run_config_extract))
        adv_menu.addSeparator()
        adv_menu.addAction(QAction("Reload Plugins", self, triggered=run_plugin_reload))

    def load_plugins(self):
        """
        Loads plugins from the plugins directory. Plugins must define hooks like on_load(pe, results) or on_strings(strings).
        """
        import importlib.util, os
        self.plugins = []
        plugins_dir = os.path.join(os.path.dirname(__file__), 'gmailscanner', 'plugins')
        if not os.path.isdir(plugins_dir):
            return
        for fname in os.listdir(plugins_dir):
            if fname.endswith('.py'):
                try:
                    spec = importlib.util.spec_from_file_location(fname[:-3], os.path.join(plugins_dir, fname))
                    mod = importlib.util.module_from_spec(spec)
                    spec.loader.exec_module(mod)
                    self.plugins.append(mod)
                except Exception as e:
                    print(f"Plugin load error {fname}: {e}")

    def run_plugin_hooks(self, hook, *args, **kwargs):
        """Run a named hook (e.g., 'on_load', 'on_strings') in all loaded plugins."""
        results = []
        for plugin in getattr(self, 'plugins', []):
            func = getattr(plugin, hook, None)
            if callable(func):
                try:
                    res = func(*args, **kwargs)
                    if res:
                        results.append(res)
                except Exception as e:
                    print(f"Plugin hook error: {e}")
        return results

    def load_ioc_db(self):
        """Load the local IOC/signature database from JSON."""
        import json, os
        db_path = os.path.join(os.path.dirname(__file__), 'gmailscanner', 'ioc_db.json')
        try:
            with open(db_path, 'r', encoding='utf-8') as f:
                self.ioc_db = json.load(f)
        except Exception as e:
            print(f"IOC DB load error: {e}")
            self.ioc_db = {}

    def check_iocs(self, results):
        """Check hashes, imports, etc. against the IOC DB. Returns a dict of hits."""
        hits = {}
        try:
            db = getattr(self, 'ioc_db', {})
            # Hashes
            hashes = results.get('basic_info', {})
            for algo in ['md5', 'sha1', 'sha256']:
                h = hashes.get(algo)
                if h and h in db.get('hashes', {}):
                    hits.setdefault('hashes', []).append({algo: h})
            # Imports
            for dll, funcs in results.get('imports', {}).items():
                if dll in db.get('imports', {}):
                    hits.setdefault('imports', []).append(dll)
            # Signatures
            for sig in results.get('signatures', {}):
                if sig in db.get('signatures', {}):
                    hits.setdefault('signatures', []).append(sig)
        except Exception as e:
            print(f"IOC check error: {e}")
        return hits

    def add_pdf_report_button(self):
        from PyQt5.QtWidgets import QPushButton
        self.save_pdf_btn = QPushButton("PDF Report")
        # Match style to Save/Load Session buttons: small, subtle, no absolute positioning
        self.save_pdf_btn.setStyleSheet("background: #3498db; color: white; padding: 6px 14px; border-radius: 4px; font-weight: 500; font-size: 12px;")
        self.save_pdf_btn.setFixedHeight(28)
        self.save_pdf_btn.setFixedWidth(120)
        self.save_pdf_btn.clicked.connect(self.save_pdf_report)
        # Add to the main layout (next to Save/Load Session buttons)
        # Place after load_session_btn if possible
        if hasattr(self, 'header_layout'):
            self.header_layout.addWidget(self.save_pdf_btn)
        elif hasattr(self, 'content_layout'):
            self.content_layout.insertWidget(1, self.save_pdf_btn)

    def save_pdf_report(self):
        from PyQt5.QtPrintSupport import QPrinter
        from PyQt5.QtGui import QTextDocument
        from PyQt5.QtWidgets import QFileDialog, QMessageBox
        if not self.current_results:
            QMessageBox.warning(self, "No Analysis", "No analysis results to export.")
            return
        results = self.current_results[-1]
        html = self.generate_full_report_html(results)
        file_path, _ = QFileDialog.getSaveFileName(self, "Save PDF Report", "analysis_report.pdf", "PDF Files (*.pdf)")
        if not file_path:
            return
        printer = QPrinter(QPrinter.HighResolution)
        printer.setOutputFormat(QPrinter.PdfFormat)
        printer.setOutputFileName(file_path)
        printer.setPageMargins(12, 16, 12, 16, QPrinter.Millimeter)
        doc = QTextDocument()
        doc.setHtml(html)
        doc.print_(printer)
        QMessageBox.information(self, "PDF Saved", f"PDF report saved to:\n{file_path}")

    def add_watermark(self, canvas, doc):
        """Add watermark to each page"""
        canvas.saveState()
        canvas.setFont('Helvetica', 70)
        canvas.setFillColor(colors.Color(0.9, 0.9, 0.9, alpha=0.3))  # Light gray, transparent
        canvas.translate(300, 400)
        canvas.rotate(45)
        canvas.drawString(0, 0, "CyberDiv101")
        canvas.restoreState()

    def generate_pdf_content(self, results):
        """Generate PDF content with improved formatting"""
        styles = getSampleStyleSheet()
        story = []

        # Custom title style
        title_style = ParagraphStyle(
            'CustomTitle',
            parent=styles['Heading1'],
            textColor=colors.HexColor('#2c3e50'),
            fontSize=24,
            spaceAfter=30
        )
        
        # Add title
        story.append(Paragraph("Malware Analysis Report", title_style))
        story.append(Spacer(1, 20))

        # Add timestamp
        story.append(Paragraph(f"Generated on: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}", 
                             ParagraphStyle('Date', textColor=colors.HexColor('#7f8c8d'))))
        story.append(Spacer(1, 30))

        # Add file information
        if hasattr(self, 'uploaded_file_path'):
            file_info = [
                ['File Information', ''],
                ['Name', os.path.basename(self.uploaded_file_path)],
                ['Path', self.uploaded_file_path],
                ['Size', f"{os.path.getsize(self.uploaded_file_path):,} bytes"],
            ]
            
            t = Table(file_info, colWidths=[2*inch, 4*inch])
            t.setStyle(TableStyle([
                ('BACKGROUND', (0, 0), (-1, 0), colors.HexColor('#3498db')),
                ('TEXTCOLOR', (0, 0), (-1, 0), colors.whitesmoke),
                ('ALIGN', (0, 0), (-1, -1), 'LEFT'),
                ('FONTNAME', (0, 0), (-1, 0), 'Helvetica-Bold'),
                ('FONTSIZE', (0, 0), (-1, 0), 14),
                ('BOTTOMPADDING', (0, 0), (-1, 0), 12),
                ('BACKGROUND', (0, 1), (-1, -1), colors.HexColor('#ecf0f1')),
                ('TEXTCOLOR', (0, 1), (-1, -1), colors.HexColor('#2c3e50')),
                ('GRID', (0, 0), (-1, -1), 1, colors.HexColor('#bdc3c7'))
            ]))
            story.append(t)
            story.append(Spacer(1, 20))

        # Add debugger analysis section with improved formatting
        if results.get('debugger_output'):
            story.append(Paragraph("Debugger Analysis", styles['Heading2']))
            story.append(Spacer(1, 10))
            
            for debugger, output in results['debugger_output'].items():
                story.append(Paragraph(f"{debugger}:", ParagraphStyle(
                    'DebuggerTitle',
                    textColor=colors.HexColor('#e74c3c'),
                    fontSize=14,
                    spaceAfter=5
                )))
                if output:
                    for line in output.split('\n'):
                        story.append(Paragraph(line, ParagraphStyle(
                            'DebuggerOutput',
                            textColor=colors.HexColor('#2c3e50'),
                            fontSize=10,
                            leftIndent=20
                        )))
                else:
                    story.append(Paragraph("No output available", ParagraphStyle(
                        'NoOutput',
                        textColor=colors.gray,
                        fontSize=10,
                        leftIndent=20
                    )))
                story.append(Spacer(1, 10))

        return story

    def generate_full_report_html(self, results):
        # Compose a full HTML report from all non-empty analysis sections
        html = "<html><head><meta charset='utf-8'><style>body{font-family:'Segoe UI',Arial,sans-serif;color:#222;}h1,h2{color:#2D3436;}table{border-collapse:collapse;width:100%;margin-bottom:18px;}th,td{border:1px solid #eee;padding:6px;}th{background:#f0f4fa;}tr:nth-child(even){background:#f8f9fa;}ul{margin:0 0 10px 20px;}section{margin-bottom:24px;}hr{margin:18px 0;}</style></head><body>"
        html += f"<h1>Malware Analysis Report</h1>"
        file_name = results.get('basic_info',{}).get('file_name','N/A')
        html += f"<h2>File: {file_name}</h2>"
        # Only include sections that have data
        # Summary
        if hasattr(self, 'summary_text') and self.summary_text.toPlainText().strip():
            html += '<hr><h2>Summary</h2>'
            html += self.summary_text.toHtml()
        # Timeline
        if hasattr(self, 'timeline_text') and self.timeline_text.toPlainText().strip():
            html += '<hr><h2>Analysis Timeline</h2>'
            html += self.timeline_text.toHtml()
        # Basic Info
        basic_info = results.get('basic_info', {})
        if basic_info:
            html += '<hr><h2>Basic Info</h2><table>'
            for key, value in basic_info.items():
                html += f'<tr><th>{key}</th><td>{value}</td></tr>'
            html += '</table>'
        # Sections
        sections = results.get('sections', [])
        if sections:
            html += '<hr><h2>Sections</h2><table>'
            html += '<tr><th>Name</th><th>VA</th><th>VS</th><th>Raw Addr</th><th>Raw Size</th><th>Virt Off</th><th>Entropy</th><th>Status</th><th>Reason</th></tr>'
            for s in sections:
                html += f"<tr><td>{s.get('Name','')}</td><td>{s.get('VirtualAddress','')}</td><td>{s.get('VirtualSize','')}</td><td>{s.get('RawAddress','')}</td><td>{s.get('RawSize','')}</td><td>{s.get('VirtualOffset','')}</td><td>{s.get('Entropy','')}</td><td>{'Suspicious' if s.get('Suspicious',False) else 'Normal'}</td><td>{', '.join(s.get('Reason',[]))}</td></tr>"
            html += '</table>'
        # Imports
        imports = results.get('imports', {})
        if imports:
            html += '<hr><h2>Imports</h2>'
            html += '<ul>'
            for dll, funcs in imports.items():
                html += f'<li><b>{dll}</b>: '
                if isinstance(funcs, list) and funcs:
                    html += ', '.join(f.get('name', str(f)) if isinstance(f, dict) else str(f) for f in funcs)
                html += '</li>'
            html += '</ul>'
        # Strings
        strings = results.get('strings', [])
        if strings:
            html += '<hr><h2>Strings</h2><ul>'
            for s in strings:
                html += f"<li>{s.get('string','')} {'<b>(Suspicious)</b>' if s.get('suspicious',False) else ''}</li>"
            html += '</ul>'
        # Network
        network = results.get('network_activity', [])
        if network:
            html += '<hr><h2>Network Activity</h2><ul>'
            for n in network:
                html += f"<li>{n.get('dll','')} - {n.get('function','')} - {n.get('address','')} - {n.get('description','')}</li>"
            html += '</ul>'
        # Entry Point
        ep = results.get('entry_point', {})
        if ep:
            html += '<hr><h2>Entry Point</h2><table>'
            html += f"<tr><th>Section</th><th>RVA</th><th>Calculated EP</th><th>Code Bytes</th></tr>"
            html += f"<tr><td>{ep.get('section_number','')}</td><td>{ep.get('entry_point_rva','')}</td><td>{ep.get('calculated_entry_point','')}</td><td>{ep.get('code_bytes','')}</td></tr>"
            html += '</table>'
            if ep.get('instructions'):
                html += '<pre>' + '\n'.join(ep.get('instructions', [])) + '</pre>'
        # Signatures
        signatures = results.get('signatures', {})
        if signatures:
            html += '<hr><h2>Signatures</h2><ul>'
            for k, v in signatures.items():
                html += f'<li><b>{k}:</b> {v}</li>'
            html += '</ul>'
        # File Access
        file_access = results.get('file_access', {})
        ascii_access = file_access.get('ascii', [])
        unicode_access = file_access.get('unicode', [])
        if ascii_access or unicode_access:
            html += '<hr><h2>File Access</h2><ul>'
            for t in ascii_access:
                html += f'<li>ASCII: {t}</li>'
            for t in unicode_access:
                html += f'<li>Unicode: {t}</li>'
            html += '</ul>'
        # Anti-VM
        anti_vm = results.get('anti_vm_sandbox', [])
        if anti_vm:
            html += '<hr><h2>Anti-VM/Sandbox</h2><ul>'
            for t in anti_vm:
                html += f'<li>{t}</li>'
            html += '</ul>'
        # URLs & IPs
        urls = results.get('urls', [])
        ips = results.get('ip_addresses', [])
        if urls:
            html += '<hr><h2>URLs</h2><ul>'
            for u in urls:
                html += f'<li>{u}</li>'
            html += '</ul>'
        if ips:
            html += '<h2>IP Addresses</h2><ul>'
            for ip in ips:
                html += f'<li>{ip}</li>'
            html += '</ul>'
        # Payloads
        payloads = results.get('payloads', [])
        if payloads:
            html += '<hr><h2>Payloads</h2><ul>'
            for p in payloads:
                html += f'<li>{p}</li>'
            html += '</ul>'
        # Extra Analysis
        extra_analysis = results.get('extra_analysis', {})
        if extra_analysis:
            html += '<hr><h2>Extra Analysis</h2><ul>'
            for k, v in extra_analysis.items():
                html += f'<li><b>{k}:</b> {v}</li>'
            html += '</ul>'
        # Indicators
        indicators = results.get('suspicious_indicators', [])
        if indicators:
            html += '<hr><h2>Suspicious Indicators</h2><ul>'
            for i in indicators:
                html += f'<li>{i}</li>'
            html += '</ul>'
        html += '</body></html>'
        return html
    # Removed local import of QLabel to prevent shadowing
    def ai_classify_malware(self, results):
        """
        Offline AI-based malware family classification using a trained ML model.
        The model should be trained on extracted features and saved as 'malware_classifier.pkl'.
        Returns (family_name, probability, risk_level) or (None, None, None) on error.
        """
        try:
            import os, joblib
            model_path = os.path.join(os.path.dirname(__file__), 'malware_classifier.pkl')
            if not os.path.exists(model_path):
                return None, None, None
            model = joblib.load(model_path)
            # Example features: entropy, suspicious imports, suspicious strings, threat score, section count, import count
            features = [
                results.get('packer_detection', {}).get('overall_entropy', 0),
                len(results.get('suspicious_indicators', [])),
                len([s for s in results.get('strings', []) if s.get('suspicious', False)]),
                results.get('threat_score', 0),
                len(results.get('sections', [])),
                len(results.get('imports', {})),
            ]
            pred = model.predict([features])[0]
            prob = model.predict_proba([features])[0].max()
            # Optionally, map pred to family name and risk level
            family_map = getattr(self, 'family_map', {
                0: 'Unknown', 1: 'Emotet', 2: 'LokiBot', 3: 'AgentTesla', 4: 'TrickBot', 5: 'Ransomware', 6: 'Infostealer', 7: 'Loader', 8: 'Backdoor', 9: 'Trojan'
            })
            risk_map = {'Emotet': 'High', 'LokiBot': 'Medium', 'AgentTesla': 'Medium', 'TrickBot': 'High', 'Ransomware': 'Critical', 'Infostealer': 'Medium', 'Loader': 'Medium', 'Backdoor': 'High', 'Trojan': 'Medium', 'Unknown': 'Unknown'}
            family = family_map.get(pred, 'Unknown')
            risk = risk_map.get(family, 'Unknown')
            return family, prob, risk
        except Exception as e:
            print(f"AI classification error: {e}")
            return None, None, None

    def detect_obfuscation(self, results):
        """Detect obfuscation/evasion: junk sections, code caves, API resolving."""
        findings = []
        try:
            # Junk sections: high entropy, zero imports
            for s in results.get('sections', []):
                if s.get('Entropy', 0) > 7.0 and not s.get('imports'):
                    findings.append(f"Junk/obfuscated section: {s.get('Name','')} (high entropy, no imports)")
            # Code caves: large gaps or anomalies near entry point
            ep = results.get('entry_point', {})
            if ep and 'entry_point_rva' in ep:
                ep_rva = ep['entry_point_rva']
                for s in results.get('sections', []):
                    va = s.get('VirtualAddress', 0)
                    vs = s.get('VirtualSize', 0)
                    if va and vs and abs(ep_rva - va) > vs:
                        findings.append(f"Possible code cave near entry point in section {s.get('Name','')}")
            # API resolving: GetProcAddress, LoadLibrary
            for s in results.get('strings', []):
                if 'GetProcAddress' in s.get('string','') or 'LoadLibrary' in s.get('string',''):
                    findings.append("Suspicious API resolving detected (GetProcAddress/LoadLibrary)")
        except Exception as e:
            findings.append(f"Obfuscation detection error: {e}")
        return findings

    def extract_config_with_plugins(self, pe, results):
        """Run config extractor plugins and collect their output."""
        configs = []
        try:
            configs = self.run_plugin_hooks('on_load', pe, results)
        except Exception as e:
            print(f"Config extractor error: {e}")
        return configs

    def export_ioc_report(self, results, fmt='json'):
        """Export IOCs (IPs, domains, file paths, mutexes, hashes, etc.) to JSON or CSV."""
        import json, csv, io
        iocs = {
            'ips': results.get('ip_addresses', []),
            'urls': results.get('urls', []),
            'file_paths': results.get('file_access', {}).get('ascii', []) + results.get('file_access', {}).get('unicode', []),
            'mutexes': results.get('mutexes', []),
            'hashes': {k: v for k, v in results.get('basic_info', {}).items() if k in ['md5', 'sha1', 'sha256']},
            'payload_hashes': results.get('payloads', []),
        }
        try:
            if fmt == 'json':
                return json.dumps(iocs, indent=2)
            elif fmt == 'csv':
                output = io.StringIO()
                writer = csv.writer(output)
                for k, v in iocs.items():
                    if isinstance(v, dict):
                        for subk, subv in v.items():
                            writer.writerow([k, subk, subv])
                    elif isinstance(v, list):
                        for item in v:
                            writer.writerow([k, item])
                return output.getvalue()
        except Exception as e:
            return f"IOC export error: {e}"

    def ai_suspicion_score(self, results):
        """AI-powered suspicion scoring using a trained model (if available)."""
        try:
            import os, joblib
            model_path = os.path.join(os.path.dirname(__file__), 'suspicion_score_model.pkl')
            if not os.path.exists(model_path):
                return None
            model = joblib.load(model_path)
            features = [
                results.get('packer_detection', {}).get('overall_entropy', 0),
                len(results.get('suspicious_indicators', [])),
                len([s for s in results.get('strings', []) if s.get('suspicious', False)]),
                results.get('threat_score', 0),
                len(results.get('sections', [])),
                len(results.get('imports', {})),
            ]
            score = model.predict([features])[0]
            return score
        except Exception as e:
            print(f"AI suspicion score error: {e}")
            return None

    def ai_generate_report(self, results):
        """
        Enhanced offline AI-powered report generation with more context and actionable insights.
        """
        try:
            basic_info = results.get('basic_info', {})
            suspicious_indicators = results.get('suspicious_indicators', [])
            suspicious_imports = sum(
                sum(1 for f in functions if f.get('suspicious', False))
                for dll, functions in results.get('imports', {}).items() if isinstance(functions, list)
            )
            suspicious_strings = [s for s in results.get('strings', []) if s.get('suspicious', False)]
            network_activity = results.get('network_activity', [])
            entropy = results.get('packer_detection', {}).get('overall_entropy', 'N/A')
            threat_score = results.get('threat_score', 'N/A')
            file_name = basic_info.get('file_name', 'N/A')
            file_type = basic_info.get('file_type', 'N/A')
            file_size = basic_info.get('file_size_readable', 'N/A')
            arch = basic_info.get('architecture', 'N/A')
            aslr = basic_info.get('aslr', 'N/A')
            creation_time = basic_info.get('creation_time', 'N/A')
            mod_time = basic_info.get('modification_time', 'N/A')
            summary = f"""
Malware Analysis AI Report\n\nFile: {file_name}\nType: {file_type}\nSize: {file_size}\nArchitecture: {arch}\nASLR: {aslr}\nCreated: {creation_time}\nModified: {mod_time}\nThreat Score: {threat_score}/100\nEntropy: {entropy}\n\nKey Findings:\n- Suspicious Indicators: {len(suspicious_indicators)}\n- Suspicious Imports: {suspicious_imports}\n- Suspicious Strings: {len(suspicious_strings)}\n- Network Activity: {len(network_activity)}\n"""
            if suspicious_indicators:
                summary += "\nTop Suspicious Indicators:\n"
                for ind in suspicious_indicators[:5]:
                    summary += f"- {ind}\n"
            if suspicious_imports > 0:
                summary += f"\nSuspicious Imports Detected: {suspicious_imports}\n"
            if suspicious_strings:
                summary += f"\nExample Suspicious Strings:\n"
                for s in suspicious_strings[:3]:
                    summary += f"- {s.get('string', '')}\n"
            if network_activity:
                summary += f"\nNetwork Activity Detected: {len(network_activity)} entries\n"
                for n in network_activity[:3]:
                    summary += f"- {n.get('dll', '')}::{n.get('function', '')} {n.get('description', '')}\n"
            # Add actionable AI suggestions
            summary += "\nAI Suggestions:\n"
            if isinstance(threat_score, (int, float)) and threat_score > 75:
                summary += "- This file is highly suspicious. Consider dynamic analysis, running in a sandbox, or submitting to a threat intelligence platform.\n"
            elif isinstance(threat_score, (int, float)) and threat_score > 50:
                summary += "- This file shows several suspicious traits. Manual review and further investigation recommended.\n"
            else:
                summary += "- No major threats detected, but review suspicious indicators and imports.\n"
            if entropy != 'N/A' and isinstance(entropy, (int, float)) and entropy > 7.0:
                summary += "- High entropy detected: possible packing or obfuscation.\n"
            if suspicious_imports > 0:
                summary += "- Review suspicious imports for malicious API usage.\n"
            if network_activity:
                summary += "- Network activity detected: check for C2 or exfiltration.\n"
            if aslr == 'Disabled':
                summary += "- ASLR is disabled: this may indicate an older or more vulnerable binary.\n"
            return summary
        except Exception as e:
            return f"AI report generation error: {e}"

    def ai_explain_indicator(self, indicator_text):
        """
        Offline AI explanation for a suspicious indicator (template-based for offline use).
        """
        try:
            # In a real offline LLM, you would call the model here.
            # For now, use a simple mapping or template.
            explanations = {
                'packer': 'Packers are used to obfuscate code and evade detection. Presence of a packer is suspicious.',
                'anti-vm': 'Anti-VM techniques are used to evade analysis in virtual environments.',
                'network': 'Network activity may indicate C2 communication or data exfiltration.',
                'suspicious import': 'Suspicious imports may be used for malicious actions such as process injection or API hooking.'
            }
            for key, val in explanations.items():
                if key in indicator_text.lower():
                    return val
            return "No specific AI explanation available for this indicator."
        except Exception as e:
            return f"AI explanation error: {e}"

    def show_ai_report_dialog(self, results):
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QTextEdit, QPushButton
        dlg = QDialog(self)
        dlg.setWindowTitle("AI-Generated Malware Report")
        layout = QVBoxLayout()
        text = QTextEdit()
        text.setReadOnly(True)
        text.setPlainText(self.ai_generate_report(results))
        layout.addWidget(text)
        btn = QPushButton("Close")
        btn.clicked.connect(dlg.accept)
        layout.addWidget(btn)
        dlg.setLayout(layout)
        dlg.resize(600, 400)
        dlg.exec_()

    def show_ai_explanation_dialog(self, indicator_text):
        from PyQt5.QtWidgets import QDialog, QVBoxLayout, QLabel, QPushButton
        dlg = QDialog(self)
        dlg.setWindowTitle("AI Explanation")
        layout = QVBoxLayout()
        label = QLabel(self.ai_explain_indicator(indicator_text))
        label.setWordWrap(True)
        layout.addWidget(label)
        btn = QPushButton("Close")
        btn.clicked.connect(dlg.accept)
        layout.addWidget(btn)
        dlg.setLayout(layout)
        dlg.resize(400, 200)
        dlg.exec_()

    def display_headers(self, results):
        self.headers_tree.clear()
        headers = results.get('headers', {})
        from PyQt5.QtWidgets import QTreeWidgetItem
        for header, props in headers.items():
            if isinstance(props, dict):
                parent = QTreeWidgetItem([header, '', ''])
                for k, v in props.items():
                    child = QTreeWidgetItem(['', str(k), str(v)])
                    parent.addChild(child)
                self.headers_tree.addTopLevelItem(parent)
            else:
                item = QTreeWidgetItem([header, '', str(props)])
                self.headers_tree.addTopLevelItem(item)
    def __init__(self):
        super().__init__()
        self.setWindowTitle("101 Cyber Div Malware Analysis and Reverse Engineering ToolKit (MARET)")
        self.setGeometry(100, 100, 1400, 900)
        self.current_results = []
        self.custom_rules = []
        self.uploaded_file_path = ""  # Store uploaded file path
        self.initUI()
        self.apply_modern_theme()
        self.add_pdf_report_button()
        self.add_advanced_analysis_menu()
        self.load_plugins()
        self.load_ioc_db()
        # Patch analysis_complete to show summaries
        if hasattr(self, 'analysis_complete'):
            orig_slot = self.analysis_complete
            def new_slot(results):
                orig_slot(results)
                self.show_analysis_summaries(results)
            self.analysis_complete = new_slot

    # Ensure apply_modern_theme is a direct method of MalwareAnalysisGUI
    def apply_modern_theme(self):
        palette = QPalette()
        palette.setColor(QPalette.Window, QColor("#F5F6FA"))
        palette.setColor(QPalette.WindowText, QColor("#2D3436"))
        palette.setColor(QPalette.Base, Qt.white)
        palette.setColor(QPalette.AlternateBase, QColor("#EDEFF2"))
        palette.setColor(QPalette.Text, QColor("#2D3436"))
        palette.setColor(QPalette.Button, QColor("#FFFFFF"))
        palette.setColor(QPalette.ButtonText, QColor("#2D3436"))
        palette.setColor(QPalette.Highlight, QColor("#006400"))
        palette.setColor(QPalette.HighlightedText, Qt.white)
        self.setPalette(palette)
        # Beautiful gradient background for the main window
        self.setStyleSheet("""
            QMainWindow {
                font-family: 'Segoe UI', Arial, sans-serif;
                background: qlineargradient(x1:0, y1:0, x2:1, y2:1,
                    stop:0 #e0eafc, stop:0.5 #cfdef3, stop:1 #a1c4fd);
            }
            QWidget#centralwidget {
                background: transparent;
            }
            QTabWidget::pane { border: none; background: rgba(255,255,255,0.95); border-radius: 8px; }
            QTabBar::tab { background: #EDEFF2; color: #2D3436; padding: 12px 20px; border: none; border-top-left-radius: 8px; border-top-right-radius: 8px; margin-right: 2px; }
            QTabBar::tab:selected { background: white; border-bottom: 2px solid #006400; }
            QPushButton { background-color: #006400; color: white; padding: 8px 16px; border: none; border-radius: 4px; font-weight: 500; }
            QPushButton:hover { background-color: #004d00; }
            QLineEdit { border: 1px solid #DFE6E9; border-radius: 4px; padding: 6px; }
            QTableWidget { border: 1px solid #DFE6E9; border-radius: 6px; background: #FAFAFA; alternate-background-color: #F0F4F8; gridline-color: #E0E0E0; selection-background-color: #90EE90; selection-color: #2D3436; }
            QTableWidget::item { padding: 8px; }
            QHeaderView::section { background-color: #006400; color: white; font-weight: bold; border: none; border-radius: 0px; padding: 8px; }
            QTreeWidget { border: 1px solid #DFE6E9; border-radius: 6px; background: #FAFAFA; alternate-background-color: #F0F4F8; }
            QTreeWidget::item { padding: 8px; }
            QTextEdit { border: 1px solid #DFE6E9; border-radius: 4px; }
            QListWidget { background: #EDEFF2; border: none; padding: 10px; }
            QListWidget::item { padding: 8px; border-radius: 4px; }
            QListWidget::item:selected { background: #006400; color: white; }
            QProgressBar { border: 1px solid #DFE6E9; border-radius: 4px; text-align: center; background: #EDEFF2; }
            QProgressBar::chunk { background-color: #006400; border-radius: 3px; }
        """)
        # Set alternating row colors for all tables if they exist
        table_names = [
            'sections_table', 'strings_table', 'network_table', 'entry_point_table',
            'signatures_table', 'file_access_ascii_table', 'file_access_unicode_table',
            'anti_vm_table', 'urls_table', 'ips_table', 'payloads_table', 'extra_analysis_table'
        ]
        for name in table_names:
            table = getattr(self, name, None)
            if table is not None:
                table.setAlternatingRowColors(True)

    def initUI(self):
        self.main_widget = QWidget()
        self.main_splitter = QSplitter(Qt.Horizontal)
        # Use QTreeWidget for collapsible sidebar
        self.sidebar = QTreeWidget()
        self.sidebar.setHeaderHidden(True)
        self.sidebar.setMaximumWidth(200)
        # Protection Analysis (collapsible)
        protection_item = QTreeWidgetItem(["PROTECTION ANALYSIS"])
        detect_it_easy_item = QTreeWidgetItem(["Detect It Easy"])
        peid_item = QTreeWidgetItem(["PEiD"])
        protection_item.addChild(detect_it_easy_item)
        protection_item.addChild(peid_item)
        protection_item.setExpanded(False)

        # Calculators
        calculators_item = QTreeWidgetItem(["CALCULATORS"])
        for label in ["Windows Calculator", "Hex Calculator", "Hash Calculator"]:
            calculators_item.addChild(QTreeWidgetItem([label]))
        calculators_item.setExpanded(False)

        # Debuggers
        debuggers_item = QTreeWidgetItem(["DEBUGGERS"])
        debugger_list = ["OllyDbg", "x64dbg", "Immunity Debugger", "GDB", "WinDbg"]
        for label in set(debugger_list):  # Using set to ensure uniqueness
            debuggers_item.addChild(QTreeWidgetItem([label]))
        debuggers_item.setExpanded(False)

        # Reverse Engineering Tools
        retools_item = QTreeWidgetItem(["REVERSE ENGINEERING TOOLS"])
        for label in ["Ghidra", "Cutter", "Binja", "RetDec", "Radare2", "Hopper"]:
            retools_item.addChild(QTreeWidgetItem([label]))
        retools_item.setExpanded(False)

        # Decompilers
        decompilers_item = QTreeWidgetItem(["DECOMPILERS"])
        for label in [
            "JADX", "Exe2Aut", "MyAutToExe", "UnAutoIt", "dnSpyEx", "ILSpy",
            "JD-GUI", "Recaf", "PyInstxtractor", "Python Decompile++", "VB Decompiler"
        ]:
            decompilers_item.addChild(QTreeWidgetItem([label]))
        decompilers_item.setExpanded(False)

        # DotNet Tools
        dotnet_item = QTreeWidgetItem(["DOTNET TOOLS"])
        for label in [
            "de4dot GUI", "dnSpyEx (x64)", "dnSpyEx (x86)", "DotDumper",
            "ExtremeDumper (x64)", "ExtremeDumper (x86)", "ILSpy", "SAE (x64)", "SAE (x86)"
        ]:
            dotnet_item.addChild(QTreeWidgetItem([label]))
        dotnet_item.setExpanded(False)

        # ELF Tools
        elf_item = QTreeWidgetItem(["ELF"])
        for label in ["elfparser-ng", "XELFViewer", "Binwalk"]:
            elf_item.addChild(QTreeWidgetItem([label]))
        elf_item.setExpanded(False)

        # Java Tools
        java_item = QTreeWidgetItem(["JAVA"])
        for label in ["JD-GUI", "JADX", "Recaf"]:
            java_item.addChild(QTreeWidgetItem([label]))
        java_item.setExpanded(False)

        # Network Tools
        network_tools_item = QTreeWidgetItem(["NETWORK"])
        for label in ["Wireshark", "Fiddler", "Burp Suite", "FakeNet-NG", "Echo Mirage", "Nmap"]:
            network_tools_item.addChild(QTreeWidgetItem([label]))
        network_tools_item.setExpanded(False)

        # Add all items to sidebar
        self.sidebar.addTopLevelItem(protection_item)
        self.sidebar.addTopLevelItem(calculators_item)
        self.sidebar.addTopLevelItem(debuggers_item)
        self.sidebar.addTopLevelItem(retools_item)
        self.sidebar.addTopLevelItem(decompilers_item)
        self.sidebar.addTopLevelItem(dotnet_item)
        self.sidebar.addTopLevelItem(elf_item)
        self.sidebar.addTopLevelItem(java_item)
        self.sidebar.addTopLevelItem(network_tools_item)
        # ...existing code for other items...
        dashboard_item = QTreeWidgetItem(["Dashboard"])
        summary_item = QTreeWidgetItem(["Summary"])
        timeline_item = QTreeWidgetItem(["Timeline"])
        basic_info_item = QTreeWidgetItem(["Basic Info"])
        headers_item = QTreeWidgetItem(["PE Headers"])
        sections_item = QTreeWidgetItem(["Sections"])
        imports_item = QTreeWidgetItem(["Imports"])
        strings_item = QTreeWidgetItem(["Strings"])
        network_item = QTreeWidgetItem(["Network Activity"])
        entry_point_item = QTreeWidgetItem(["Entry Point"])
        signatures_item = QTreeWidgetItem(["Signatures"])
        file_access_item = QTreeWidgetItem(["File Access"])
        anti_vm_item = QTreeWidgetItem(["Anti-VM/Sandbox"])
        urls_ips_item = QTreeWidgetItem(["URLs & IPs"])
        payloads_item = QTreeWidgetItem(["Payloads"])
        extra_analysis_item = QTreeWidgetItem(["Extra Analysis"])
        indicators_item = QTreeWidgetItem(["Suspicious Indicators"])
        self.sidebar.addTopLevelItem(dashboard_item)
        self.sidebar.addTopLevelItem(summary_item)
        self.sidebar.addTopLevelItem(timeline_item)
        self.sidebar.addTopLevelItem(basic_info_item)
        self.sidebar.addTopLevelItem(headers_item)
        self.sidebar.addTopLevelItem(sections_item)
        self.sidebar.addTopLevelItem(imports_item)
        self.sidebar.addTopLevelItem(strings_item)
        self.sidebar.addTopLevelItem(network_item)
        self.sidebar.addTopLevelItem(entry_point_item)
        self.sidebar.addTopLevelItem(signatures_item)
        self.sidebar.addTopLevelItem(file_access_item)
        self.sidebar.addTopLevelItem(anti_vm_item)
        self.sidebar.addTopLevelItem(urls_ips_item)
        self.sidebar.addTopLevelItem(payloads_item)
        self.sidebar.addTopLevelItem(extra_analysis_item)
        self.sidebar.addTopLevelItem(indicators_item)
        self.sidebar.itemClicked.connect(self.change_tab_tree)
        self.sidebar.itemExpanded.connect(self.handle_sidebar_expand)
        # Show sidebar and main content
        # Ensure content_widget is created before adding to splitter
        if not hasattr(self, 'content_widget'):
            self.content_widget = QWidget()
            self.content_layout = QVBoxLayout()
            self.content_widget.setLayout(self.content_layout)

        # --- FIX: Add main content sections on startup ---
        self.create_header_section()
        self.create_status_section()
        self.create_results_tabs()
        # --- END FIX ---

        self.main_splitter.addWidget(self.sidebar)
        self.main_splitter.addWidget(self.content_widget)
        self.main_splitter.setSizes([200, 1200])
        self.setCentralWidget(self.main_splitter)

    def handle_sidebar_expand(self, item):
        """
        Ensures only one main collapsible sidebar section is open at a time.
        When a main section is expanded, all others are collapsed.
        """
        # Only act on top-level items (main sections)
        try:
            if item.parent() is not None:
                return
            collapsible_titles = [
                "PROTECTION ANALYSIS", "CALCULATORS", "DEBUGGERS",
                "REVERSE ENGINEERING TOOLS", "DECOMPILERS", "DOTNET TOOLS"
            ]
            if item.text(0) in collapsible_titles:
                count = self.sidebar.topLevelItemCount()
                for i in range(count):
                    top_item = self.sidebar.topLevelItem(i)
                    if top_item is not item and top_item.text(0) in collapsible_titles:
                        top_item.setExpanded(False)
        except Exception as e:
            # Defensive: log or print error, but do not crash
            print(f"Sidebar expand error: {e}")

    def create_header_section(self):
        header_layout = QHBoxLayout()
        
        # Add logo 1 (Horse with Lock)
        self.logo1_label = QLabel(self)
        logo1_pixmap = QPixmap("logo1.png")  # Replace with your first logo file path
        if not logo1_pixmap.isNull():
            scaled_pixmap = logo1_pixmap.scaled(50, 50, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.logo1_label.setPixmap(scaled_pixmap)
            self.logo1_label.setScaledContents(True)
            self.logo1_label.setMaximumWidth(60)
            self.logo1_label.setMaximumHeight(60)
        header_layout.addWidget(self.logo1_label)

        # Add logo 2 (Pakistan Emblem)
        self.logo2_label = QLabel(self)
        logo2_pixmap = QPixmap("logo2.png")  # Replace with your second logo file path
        if not logo2_pixmap.isNull():
            scaled_pixmap = logo2_pixmap.scaled(50, 50, Qt.KeepAspectRatio, Qt.SmoothTransformation)
            self.logo2_label.setPixmap(scaled_pixmap)
            self.logo2_label.setScaledContents(True)
            self.logo2_label.setMaximumWidth(60)
            self.logo2_label.setMaximumHeight(60)
        header_layout.addWidget(self.logo2_label)

        # Add spacing between logos and other elements
        header_layout.addSpacing(10)

        # Existing controls
        self.upload_btn = QPushButton("Upload File")
        self.upload_btn.clicked.connect(self.upload_file)
        self.file_label = QLabel("No file selected")
        self.file_label.setStyleSheet("font-weight: 500;")
        self.save_session_btn = QPushButton("Save Session")
        self.save_session_btn.clicked.connect(self.save_session)
        self.save_session_btn.setEnabled(False)
        self.load_session_btn = QPushButton("Load Session")
        self.load_session_btn.clicked.connect(self.load_session)

        # Add controls to layout
        header_layout.addWidget(self.upload_btn)
        header_layout.addWidget(self.file_label, 1)
        header_layout.addWidget(self.save_session_btn)
        header_layout.addWidget(self.load_session_btn)

        self.content_layout.addLayout(header_layout)

    def create_status_section(self):
        status_layout = QHBoxLayout()
        self.status_label = QLabel("Ready")
        self.status_label.setStyleSheet("font-weight: 500; color: #636E72;")
        self.progress_bar = QProgressBar()
        self.progress_bar.setRange(0, 100)
        self.progress_bar.setValue(0)
        self.progress_bar.setTextVisible(True)
        status_layout.addWidget(self.status_label, 1)
        status_layout.addWidget(self.progress_bar)
        self.content_layout.addLayout(status_layout)

    def create_results_tabs(self):
        self.tabs = QTabWidget()
        self.tabs.setStyleSheet("margin-top: 10px;")
        # Protection Analysis Tab
        self.protection_analysis_tab = QTabWidget()
        self.detect_it_easy_tab = QWidget()
        self.detect_it_easy_layout = QVBoxLayout()
        self.detect_it_easy_text = QTextEdit()
        self.detect_it_easy_text.setReadOnly(True)
        self.detect_it_easy_layout.addWidget(self.detect_it_easy_text)
        self.detect_it_easy_tab.setLayout(self.detect_it_easy_layout)
        self.peid_tab = QWidget()
        self.peid_layout = QVBoxLayout()
        self.peid_text = QTextEdit()
        self.peid_text.setReadOnly(True)
        self.peid_layout.addWidget(self.peid_text)
        self.peid_tab.setLayout(self.peid_layout)
        self.protection_analysis_tab.addTab(self.detect_it_easy_tab, "Detect It Easy")
        self.protection_analysis_tab.addTab(self.peid_tab, "PEiD")
        self.tabs.insertTab(0, self.protection_analysis_tab, "Protection Analysis")

        # Calculators Tab (with three sub-tabs: Windows, Hex, Hash)
        self.calculators_tab = QTabWidget()
        # --- Windows Calculator Sub-tab ---
        win_calc_tab = QWidget()
        win_layout = QVBoxLayout()
        win_btn = QPushButton("Launch Windows Calculator")
        import subprocess
        win_btn.clicked.connect(lambda: subprocess.Popen('calc.exe'))
        win_layout.addWidget(win_btn)
        win_calc_tab.setLayout(win_layout)
        self.calculators_tab.addTab(win_calc_tab, "Windows Calculator")

        # --- Hex Calculator Sub-tab ---
        hex_calc_tab = QWidget()
        hex_layout = QVBoxLayout()
        hex_group = QGroupBox("Hex Converter (from uploaded file)")
        hex_form = QFormLayout()
        self.offset_input = QLineEdit("0")
        self.offset_input.setPlaceholderText("Byte offset (default 0)")
        self.length_input = QLineEdit("4")
        self.length_input.setPlaceholderText("Number of bytes (default 4)")
        self.hex_input = QLineEdit()
        self.dec_input = QLineEdit()
        self.bin_input = QLineEdit()
        self.ascii_input = QLineEdit()
        for w in [self.hex_input, self.dec_input, self.bin_input, self.ascii_input]:
            w.setReadOnly(True)
        hex_form.addRow("Offset:", self.offset_input)
        hex_form.addRow("Length:", self.length_input)
        hex_form.addRow("Hex:", self.hex_input)
        hex_form.addRow("Decimal:", self.dec_input)
        hex_form.addRow("Binary:", self.bin_input)
        hex_form.addRow("ASCII:", self.ascii_input)
        hex_btn = QPushButton("Read Bytes from File")
        def update_hex_from_file():
            if not hasattr(self, 'uploaded_file_path') or not self.uploaded_file_path or not os.path.exists(self.uploaded_file_path):
                self.hex_input.setText('')
                self.dec_input.setText('')
                self.bin_input.setText('')
                self.ascii_input.setText('')
                QMessageBox.warning(self, "No File", "Please upload a file first.")
                return
            try:
                offset = int(self.offset_input.text() or '0')
                length = int(self.length_input.text() or '4')
                with open(self.uploaded_file_path, 'rb') as f:
                    f.seek(offset)
                    data = f.read(length)
                if not data:
                    self.hex_input.setText('')
                    self.dec_input.setText('')
                    self.bin_input.setText('')
                    self.ascii_input.setText('')
                    return
                hex_val = data.hex()
                dec_val = int.from_bytes(data, 'big')
                bin_val = bin(dec_val)[2:]
                ascii_val = ''.join(chr(b) if 32 <= b < 127 else '.' for b in data)
                self.hex_input.setText(hex_val)
                self.dec_input.setText(str(dec_val))
                self.bin_input.setText(bin_val)
                self.ascii_input.setText(ascii_val)
            except Exception as e:
                self.hex_input.setText('Error')
                self.dec_input.setText('Error')
                self.bin_input.setText('Error')
                self.ascii_input.setText('Error')
                QMessageBox.critical(self, "Error", f"Failed to read bytes: {str(e)}")
        hex_btn.clicked.connect(update_hex_from_file)
        hex_form.addRow(hex_btn)
        hex_group.setLayout(hex_form)
        hex_layout.addWidget(hex_group)
        hex_calc_tab.setLayout(hex_layout)
        self.calculators_tab.addTab(hex_calc_tab, "Hex Calculator")

        # --- Hash Calculator Sub-tab ---
        hash_calc_tab = QWidget()
        hash_layout = QVBoxLayout()
        hash_group = QGroupBox("File Hash Calculator (uploaded file)")
        hash_form = QFormLayout()
        self.hash_file_label = QLabel()
        self.md5_output = QLineEdit()
        self.md5_output.setReadOnly(True)
        self.sha1_output = QLineEdit()
        self.sha1_output.setReadOnly(True)
        self.sha256_output = QLineEdit()
        self.sha256_output.setReadOnly(True)
        hash_btn = QPushButton("Calculate Hashes")
        import hashlib
        def update_hashes_from_file():
            if not hasattr(self, 'uploaded_file_path') or not self.uploaded_file_path or not os.path.exists(self.uploaded_file_path):
                self.hash_file_label.setText('No file uploaded')
                self.md5_output.setText('')
                self.sha1_output.setText('')
                self.sha256_output.setText('')
                QMessageBox.warning(self, "No File", "Please upload a file first.")
                return
            self.hash_file_label.setText(os.path.basename(self.uploaded_file_path))
            try:
                with open(self.uploaded_file_path, 'rb') as f:
                    data = f.read()
                md5 = hashlib.md5(data).hexdigest()
                sha1 = hashlib.sha1(data).hexdigest()
                sha256 = hashlib.sha256(data).hexdigest()
                self.md5_output.setText(md5)
                self.sha1_output.setText(sha1)
                self.sha256_output.setText(sha256)
            except Exception as e:
                self.md5_output.setText('Error')
                self.sha1_output.setText('Error')
                self.sha256_output.setText('Error')
                QMessageBox.critical(self, "Error", f"Failed to calculate hashes: {str(e)}")
        hash_btn.clicked.connect(update_hashes_from_file)
        hash_form.addRow("File:", self.hash_file_label)
        hash_form.addRow("MD5:", self.md5_output)
        hash_form.addRow("SHA-1:", self.sha1_output)
        hash_form.addRow("SHA-256:", self.sha256_output)
        hash_form.addRow(hash_btn)
        hash_group.setLayout(hash_form)
        hash_layout.addWidget(hash_group)
        hash_calc_tab.setLayout(hash_layout)
        self.calculators_tab.addTab(hash_calc_tab, "Hash Calculator")

        self.tabs.insertTab(1, self.calculators_tab, "Calculators")

        # Debuggers Tab
        self.debuggers_tab = QTabWidget()
        dbg_labels = ["OllyDbg", "x64dbg", "Immunity Debugger", "GDB", "WinDbg"]
        dbg_methods = {
            "OllyDbg": self.analyze_with_ollydbg,
            "x64dbg": self.analyze_with_x64dbg,
            "Immunity Debugger": self.analyze_with_immunity,
            "GDB": self.analyze_with_gdb,
            "WinDbg": self.analyze_with_windbg
        }
        
        for label in dbg_labels:
            # Create tab and its layout
            tab = QWidget()
            layout = QVBoxLayout()
            # Add header label
            layout.addWidget(QLabel(f"{label} Analysis"))
            # Create and store file label
            file_label = QLabel("No file selected")
            setattr(self, f"{label.lower().replace(' ', '_')}_file_label", file_label)
            layout.addWidget(file_label)
            # Create and store analyze button
            analyze_btn = QPushButton(f"Analyze with {label}")
            analyze_btn.setEnabled(False)
            setattr(self, f"{label.lower().replace(' ', '_')}_analyze_btn", analyze_btn)
            # Create and store results area
            results_text = QTextEdit()
            results_text.setReadOnly(True)
            results_text.setPlaceholderText(f"Analysis results from {label} will appear here...")
            setattr(self, f"{label.lower().replace(' ', '_')}_results", results_text)
            # Connect button to analysis method using a lambda to pass label and method
            if label in dbg_methods:
                analyze_btn.clicked.connect(lambda checked, l=label, m=dbg_methods[label]: self.run_debugger_analysis(l, m))
            # Add widgets to layout
            layout.addWidget(analyze_btn)
            layout.addWidget(results_text)
            # Set layout and add tab
            tab.setLayout(layout)
            self.debuggers_tab.addTab(tab, label)
            
        self.tabs.insertTab(2, self.debuggers_tab, "Debuggers")

        # Reverse Engineering Tools Tab
        self.retools_tab = QTabWidget()
        # --- Ghidra (Disassembly) ---
        ghidra_tab = QWidget()
        ghidra_layout = QVBoxLayout()
        ghidra_text = QTextEdit(); ghidra_text.setReadOnly(True)
        ghidra_layout.addWidget(QLabel("Ghidra (Pro Disassembly)"))
        ghidra_layout.addWidget(ghidra_text)
        ghidra_btn = QPushButton("Disassemble All Code Sections (PE/ELF)")
        def run_ghidra_disasm():
            try:
                import pefile
                from capstone import Cs, CS_ARCH_X86, CS_MODE_32, CS_MODE_64
                import os
                if not self.uploaded_file_path:
                    ghidra_text.setPlainText("No file uploaded.")
                    return
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if ext in ['.exe', '.dll']:
                    pe = pefile.PE(self.uploaded_file_path)
                    mode = CS_MODE_64 if pe.FILE_HEADER.Machine == 0x8664 else CS_MODE_32
                    md = Cs(CS_ARCH_X86, mode)
                    disasm = ''
                    for section in pe.sections:
                        if b'code' in section.Name.lower() or section.Characteristics & 0x20:
                            data = section.get_data()
                            va = pe.OPTIONAL_HEADER.ImageBase + section.VirtualAddress
                            disasm += f"\n; Section {section.Name.decode(errors='ignore').strip()}\n"
                            for i in md.disasm(data, va):
                                disasm += f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}\n"
                    ghidra_text.setPlainText(disasm or "No code sections found.")
                elif ext in ['.elf']:
                    from elftools.elf.elffile import ELFFile
                    with open(self.uploaded_file_path, 'rb') as f:
                        elf = ELFFile(f)
                        text = elf.get_section_by_name('.text')
                        if not text:
                            ghidra_text.setPlainText("No .text section found.")
                            return
                        data = text.data()
                        md = Cs(CS_ARCH_X86, CS_MODE_64)
                        disasm = ''
                        for i in md.disasm(data, text['sh_addr']):
                            disasm += f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}\n"
                        ghidra_text.setPlainText(disasm or "No instructions found.")
                else:
                    ghidra_text.setPlainText("Unsupported file type.")
            except Exception as e:
                ghidra_text.setPlainText(f"Error: {e}")
        ghidra_btn.clicked.connect(run_ghidra_disasm)
        ghidra_layout.addWidget(ghidra_btn)
        ghidra_tab.setLayout(ghidra_layout)
        self.retools_tab.addTab(ghidra_tab, "Ghidra")

        # --- Cutter (Hex View) ---
        cutter_tab = QWidget()
        cutter_layout = QVBoxLayout()
        cutter_text = QTextEdit()
        cutter_text.setReadOnly(True)
        cutter_layout.addWidget(QLabel("Cutter (Hex View Simulation)"))
        cutter_layout.addWidget(cutter_text)
        cutter_btn = QPushButton("Show First 256 Bytes as Hex")
        def run_cutter_hex():
            try:
                if not self.uploaded_file_path:
                    cutter_text.setPlainText("No file uploaded.")
                    return
                with open(self.uploaded_file_path, "rb") as f:
                    data = f.read(256)
                hexstr = ' '.join(f'{b:02X}' for b in data)
                cutter_text.setPlainText(hexstr)
            except Exception as e:
                cutter_text.setPlainText(f"Error: {e}")
        cutter_btn.clicked.connect(run_cutter_hex)
        cutter_layout.addWidget(cutter_btn)
        cutter_tab.setLayout(cutter_layout)
        self.retools_tab.addTab(cutter_tab, "Cutter")

        # --- Binja (Function List) ---
        binja_tab = QWidget()
        binja_layout = QVBoxLayout()
        binja_text = QTextEdit(); binja_text.setReadOnly(True)
        binja_layout.addWidget(QLabel("Binja (Function List - PE/ELF/.NET)", self))
        binja_layout.addWidget(binja_text)
        binja_btn = QPushButton("List All Functions (PE/ELF/.NET)")
        def run_binja_funcs():
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path:
                    binja_text.setPlainText("No file uploaded.")
                    return
                if ext in ['.exe', '.dll']:
                    import pefile
                    pe = pefile.PE(self.uploaded_file_path)
                    funcs = []
                    if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                        funcs += [e.name.decode() for e in pe.DIRECTORY_ENTRY_EXPORT.symbols if e.name]
                    # .NET: try dnfile for managed methods
                    try:
                        import dnfile
                        dn = dnfile.dnPE(self.uploaded_file_path)
                        if dn.net and dn.net.mdtables:
                            for row in dn.net.mdtables.MethodDef:
                                name = row.Name
                                if name:
                                    funcs.append(f"[.NET] {name}")
                    except Exception:
                        pass
                    binja_text.setPlainText('\n'.join(funcs) or "No exported or managed functions.")
                elif ext in ['.elf']:
                    from elftools.elf.elffile import ELFFile
                    with open(self.uploaded_file_path, 'rb') as f:
                        elf = ELFFile(f)
                        funcs = []
                        for section in elf.iter_sections():
                            if section.name == '.symtab':
                                for sym in section.iter_symbols():
                                    if sym['st_info']['type'] == 'STT_FUNC':
                                        funcs.append(sym.name)
                        binja_text.setPlainText('\n'.join(funcs) or "No functions found.")
                else:
                    binja_text.setPlainText("Unsupported file type.")
            except Exception as e:
                binja_text.setPlainText(f"Error: {e}")
        binja_btn.clicked.connect(run_binja_funcs)
        binja_layout.addWidget(binja_btn)
        binja_tab.setLayout(binja_layout)
        self.retools_tab.addTab(binja_tab, "Binja")

        # --- RetDec (Pseudo-code Simulation) ---
        retdec_tab = QWidget()
        retdec_layout = QVBoxLayout()
        retdec_text = QTextEdit()
        retdec_text.setReadOnly(True)
        retdec_layout.addWidget(QLabel("RetDec (Pseudo-code Simulation)", self))
        retdec_layout.addWidget(retdec_text)
        retdec_btn = QPushButton("Show Pseudo-code for Entry Point")
        def run_retdec_pseudo():
            try:
                import pefile
                if not self.uploaded_file_path:
                    retdec_text.setPlainText("No file uploaded.")
                    return
                pe = pefile.PE(self.uploaded_file_path)
                entry = pe.OPTIONAL_HEADER.AddressOfEntryPoint
                base = pe.OPTIONAL_HEADER.ImageBase
                data = pe.get_memory_mapped_image()[entry:entry+16]
                # Fake pseudo-code for demo
                pseudo = f"void entry() {{\n    // Entry RVA: 0x{entry:X}\n    // Bytes: {data.hex()}\n    // ...\n}}"
                retdec_text.setPlainText(pseudo)
            except Exception as e:
                retdec_text.setPlainText(f"Error: {e}")
        retdec_btn.clicked.connect(run_retdec_pseudo)
        retdec_layout.addWidget(retdec_btn)
        retdec_tab.setLayout(retdec_layout)
        self.retools_tab.addTab(retdec_tab, "RetDec")

        # --- Radare2 (Section Info) ---
        radare_tab = QWidget()
        radare_layout = QVBoxLayout()
        radare_text = QTextEdit()
        radare_text.setReadOnly(True)
        radare_layout.addWidget(QLabel("Radare2 (Section Info Simulation)"))
        radare_layout.addWidget(radare_text)
        radare_btn = QPushButton("Show Section Table (PE)")
        def run_radare_sections():
            try:
                import pefile
                if not self.uploaded_file_path:
                    radare_text.setPlainText("No file uploaded.")
                    return
                pe = pefile.PE(self.uploaded_file_path)
                info = ""
                for s in pe.sections:
                    info += f"{s.Name.decode(errors='ignore').strip()}\tVA: 0x{s.VirtualAddress:X}\tSize: {s.SizeOfRawData}\n"
                radare_text.setPlainText(info or "No sections found.")
            except Exception as e:
                radare_text.setPlainText(f"Error: {e}")
        radare_btn.clicked.connect(run_radare_sections)
        radare_layout.addWidget(radare_btn)
        radare_tab.setLayout(radare_layout)
        self.retools_tab.addTab(radare_tab, "Radare2")

        # --- Hopper (String Extraction) ---
        hopper_tab = QWidget()
        hopper_layout = QVBoxLayout()
        hopper_text = QTextEdit()
        hopper_text.setReadOnly(True)
        hopper_layout.addWidget(QLabel("Hopper (String Extraction Simulation)"))
        hopper_layout.addWidget(hopper_text)
        hopper_btn = QPushButton("Extract ASCII Strings")
        def run_hopper_strings():
            try:
                import re
                if not self.uploaded_file_path:
                    hopper_text.setPlainText("No file uploaded.")
                    return
                with open(self.uploaded_file_path, "rb") as f:
                    data = f.read()
                strings = re.findall(rb"[ -~]{6,}", data)
                hopper_text.setPlainText('\n'.join(s.decode(errors='ignore') for s in strings) or "No ASCII strings found.")
            except Exception as e:
                hopper_text.setPlainText(f"Error: {e}")
        hopper_btn.clicked.connect(run_hopper_strings)
        hopper_layout.addWidget(hopper_btn)
        hopper_tab.setLayout(hopper_layout)
        self.retools_tab.addTab(hopper_tab, "Hopper")

        self.tabs.insertTab(3, self.retools_tab, "Reverse Engineering Tools")

        # Decompilers Tab
        self.decompilers_tab = QTabWidget()
        # --- JADX (Java Decompiler Simulation) ---
        jadx_tab = QWidget()
        jadx_layout = QVBoxLayout()
        jadx_text = QTextEdit(); jadx_text.setReadOnly(True)
        jadx_layout.addWidget(QLabel("JADX (Java Decompiler - Class File)", self))
        jadx_layout.addWidget(jadx_text)
        jadx_btn = QPushButton("Show Java Methods (class file)")
        def run_jadx():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.class'):
                    jadx_text.setPlainText("No Java .class file uploaded.")
                    return
                # Parse class file for method names
                def parse_class_methods(data):
                    import struct
                    cp_count = struct.unpack('>H', data[8:10])[0]
                    i = 10
                    cp = []
                    while len(cp) < cp_count-1:
                        tag = data[i]
                        if tag == 1: # UTF-8
                            l = struct.unpack('>H', data[i+1:i+3])[0]
                            cp.append(data[i+3:i+3+l].decode(errors='ignore'))
                            i += 3+l
                        elif tag in (3,4):
                            i += 5; cp.append(None)
                        elif tag in (5,6):
                            i += 9; cp.append(None)
                        elif tag in (7,8):
                            i += 3; cp.append(None)
                        elif tag in (9,10,11,12,15,16,18):
                            i += 5; cp.append(None)
                        else:
                            break
                    # Find method names
                    methods = []
                    idx = data.find(b'method')
                    if idx != -1:
                        methods.append('method')
                    return cp, methods
                with open(self.uploaded_file_path, 'rb') as f:
                    data = f.read()
                cp, methods = parse_class_methods(data)
                jadx_text.setPlainText("Constant Pool:\n" + '\n'.join(str(x) for x in cp if x) + "\n\nMethods:\n" + '\n'.join(methods) if methods else "No methods found.")
            except Exception as e:
                jadx_text.setPlainText(f"Error: {e}")
        jadx_btn.clicked.connect(run_jadx)
        jadx_layout.addWidget(jadx_btn)
        jadx_tab.setLayout(jadx_layout)
        self.decompilers_tab.addTab(jadx_tab, "JADX")

        # --- Exe2Aut (AutoIt Extraction Simulation) ---
        exe2aut_tab = QWidget()
        exe2aut_layout = QVBoxLayout()
        exe2aut_text = QTextEdit(); exe2aut_text.setReadOnly(True)
        exe2aut_layout.addWidget(QLabel("Exe2Aut (AutoIt Extraction Simulation)"))
        exe2aut_layout.addWidget(exe2aut_text)
        exe2aut_btn = QPushButton("Extract AutoIt Script (EXE)")
        def run_exe2aut():
            exe2aut_text.setPlainText("Simulated: Extracted AutoIt script would appear here if EXE is AutoIt-packed.")
        exe2aut_btn.clicked.connect(run_exe2aut)
        exe2aut_layout.addWidget(exe2aut_btn)
        exe2aut_tab.setLayout(exe2aut_layout)
        self.decompilers_tab.addTab(exe2aut_tab, "Exe2Aut")

        # --- MyAutToExe (AutoIt Reverse Simulation) ---
        myaut_tab = QWidget()
        myaut_layout = QVBoxLayout()
        myaut_text = QTextEdit(); myaut_text.setReadOnly(True)
        myaut_layout.addWidget(QLabel("MyAutToExe (AutoIt Reverse Simulation)"))
        myaut_layout.addWidget(myaut_text)
        myaut_btn = QPushButton("Reverse AutoIt EXE")
        def run_myaut():
            myaut_text.setPlainText("Simulated: Decompiled AutoIt code would appear here.")
        myaut_btn.clicked.connect(run_myaut)
        myaut_layout.addWidget(myaut_btn)
        myaut_tab.setLayout(myaut_layout)
        self.decompilers_tab.addTab(myaut_tab, "MyAutToExe")

        # --- UnAutoIt (AutoIt Unpacker Simulation) ---
        unautoit_tab = QWidget()
        unautoit_layout = QVBoxLayout()
        unautoit_text = QTextEdit(); unautoit_text.setReadOnly(True)
        unautoit_layout.addWidget(QLabel("UnAutoIt (AutoIt Unpacker Simulation)"))
        unautoit_layout.addWidget(unautoit_text)
        unautoit_btn = QPushButton("Unpack AutoIt EXE")
        def run_unautoit():
            unautoit_text.setPlainText("Simulated: Unpacked AutoIt script would appear here.")
        unautoit_btn.clicked.connect(run_unautoit)
        unautoit_layout.addWidget(unautoit_btn)
        unautoit_tab.setLayout(unautoit_layout)
        self.decompilers_tab.addTab(unautoit_tab, "UnAutoIt")

        # --- dnSpyEx (Show .NET Methods) ---
        dnspyex_tab = QWidget()
        dnspyex_layout = QVBoxLayout()
        dnspyex_text = QTextEdit(); dnspyex_text.setReadOnly(True)
        dnspyex_layout.addWidget(QLabel("dnSpyEx (Show .NET Methods)", self))
        dnspyex_layout.addWidget(dnspyex_text)
        dnspyex_btn = QPushButton("List .NET Methods (DLL/EXE)")
        def run_dnspyex():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith(('.exe', '.dll')):
                    dnspyex_text.setPlainText("No .NET EXE/DLL uploaded.")
                    return
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                methods = []
                if dn.net and dn.net.mdtables:
                    for row in dn.net.mdtables.MethodDef:
                        name = row.Name
                        if name:
                            methods.append(name)
                dnspyex_text.setPlainText('\n'.join(methods) or "No .NET methods found.")
            except Exception as e:
                dnspyex_text.setPlainText(f"Error: {e}")
        dnspyex_btn.clicked.connect(run_dnspyex)
        dnspyex_layout.addWidget(dnspyex_btn)
        dnspyex_tab.setLayout(dnspyex_layout)
        self.decompilers_tab.addTab(dnspyex_tab, "dnSpyEx")

        # --- ILSpy (Show IL Code Simulation) ---
        ilspy_tab = QWidget()
        ilspy_layout = QVBoxLayout()
        ilspy_text = QTextEdit(); ilspy_text.setReadOnly(True)
        ilspy_layout.addWidget(QLabel("ILSpy (Show Real IL Code for .NET)", self))
        ilspy_layout.addWidget(ilspy_text)
        ilspy_btn = QPushButton("Show IL Code (DLL/EXE)")
        def run_ilspy():
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path or ext not in ['.exe', '.dll']:
                    ilspy_text.setPlainText("No .NET EXE/DLL uploaded.")
                    return
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                il_lines = []
                if dn.net and dn.net.mdtables:
                    for row in dn.net.mdtables.MethodDef:
                        name = row.Name
                        rva = row.RVA
                        il_lines.append(f".method {name} (RVA: 0x{rva:X})")
                ilspy_text.setPlainText('\n'.join(il_lines) or "No IL code found.")
            except Exception as e:
                ilspy_text.setPlainText(f"Error: {e}")
        ilspy_btn.clicked.connect(run_ilspy)
        ilspy_layout.addWidget(ilspy_btn)
        ilspy_tab.setLayout(ilspy_layout)
        self.decompilers_tab.addTab(ilspy_tab, "ILSpy")

        # --- JD-GUI (Java Bytecode to Source Simulation) ---
        jdgui_tab = QWidget()
        jdgui_layout = QVBoxLayout()
        jdgui_text = QTextEdit(); jdgui_text.setReadOnly(True)
        jdgui_layout.addWidget(QLabel("JD-GUI (Java Bytecode to Source Simulation)"))
        jdgui_layout.addWidget(jdgui_text)
        jdgui_btn = QPushButton("Show Decompiled Java Source")
        def run_jdgui():
            try:
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.class'):
                    jdgui_text.setPlainText("No Java .class file uploaded.")
                    return
                
                # Use javatools (if available) for real decompilation, else show constant pool
                try:
                    from javatools import ClassFile
                    with open(self.uploaded_file_path, 'rb') as f:
                        cf = ClassFile(f)
                        src = cf.decompile()
                        jdgui_text.setPlainText(src)
                except Exception:
                    # Fallback: show constant pool
                    with open(self.uploaded_file_path, 'rb') as f:
                        data = f.read()
                    cp = []
                    i = 8
                    count = int.from_bytes(data[8:10], 'big')
                    jdgui_text.setPlainText("Constant Pool Info: " + str(count) + " entries")
            except Exception as e:
                jdgui_text.setPlainText(f"Error: {e}")
        jdgui_btn.clicked.connect(run_jdgui)
        jdgui_layout.addWidget(jdgui_btn)
        jdgui_tab.setLayout(jdgui_layout)
        self.decompilers_tab.addTab(jdgui_tab, "JD-GUI")

        # --- Recaf (Java Class Analysis Simulation) ---
        recaf_tab = QWidget()
        recaf_layout = QVBoxLayout()
        recaf_text = QTextEdit(); recaf_text.setReadOnly(True)
        recaf_layout.addWidget(QLabel("Recaf (Java Class Analysis Simulation)"))
        recaf_layout.addWidget(recaf_text)
        recaf_btn = QPushButton("Analyze Java Class")
        def run_recaf():
            recaf_text.setPlainText("Simulated: Java class analysis would be shown here.")
        recaf_btn.clicked.connect(run_recaf)
        recaf_layout.addWidget(recaf_btn)
        recaf_tab.setLayout(recaf_layout)
        self.decompilers_tab.addTab(recaf_tab, "Recaf")

        # --- PyInstxtractor (Python EXE Extraction Simulation) ---
        pyinst_tab = QWidget()
        pyinst_layout = QVBoxLayout()
        pyinst_text = QTextEdit(); pyinst_text.setReadOnly(True)
        pyinst_layout.addWidget(QLabel("PyInstxtractor (Python EXE Extraction Simulation)"))
        pyinst_layout.addWidget(pyinst_text)
        pyinst_btn = QPushButton("Extract Python Code from EXE")
        def run_pyinst():
            pyinst_text.setPlainText("Simulated: Extracted Python code from EXE would be shown here.")
        pyinst_btn.clicked.connect(run_pyinst)
        pyinst_layout.addWidget(pyinst_btn)
        pyinst_tab.setLayout(pyinst_layout)
        self.decompilers_tab.addTab(pyinst_tab, "PyInstxtractor")

        # --- Python Decompile++ (Python Bytecode Decompilation Simulation) ---
        pydecomp_tab = QWidget()
        pydecomp_layout = QVBoxLayout()
        pydecomp_text = QTextEdit(); pydecomp_text.setReadOnly(True)
        pydecomp_layout.addWidget(QLabel("Python Decompile++ (Bytecode Decompilation)", self))
        pydecomp_layout.addWidget(pydecomp_text)
        pydecomp_btn = QPushButton("Decompile Python Bytecode (.pyc)")
        def run_pydecomp():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.pyc'):
                    pydecomp_text.setPlainText("No .pyc file uploaded.")
                    return
                import uncompyle6
                from io import StringIO
                out = StringIO()
                uncompyle6.decompile_file(self.uploaded_file_path, out)
                pydecomp_text.setPlainText(out.getvalue())
            except Exception as e:
                pydecomp_text.setPlainText(f"Error: {e}")
        pydecomp_btn.clicked.connect(run_pydecomp)
        pydecomp_layout.addWidget(pydecomp_btn)
        pydecomp_tab.setLayout(pydecomp_layout)
        self.decompilers_tab.addTab(pydecomp_tab, "Python Decompile++")

        # --- VB Decompiler (VB Code Simulation) ---
        vb_tab = QWidget()
        vb_layout = QVBoxLayout()
        vb_text = QTextEdit(); vb_text.setReadOnly(True)
        vb_layout.addWidget(QLabel("VB Decompiler (VB Code Simulation)"))
        vb_layout.addWidget(vb_text)
        vb_btn = QPushButton("Show Decompiled VB Code")
        def run_vb():
            vb_text.setPlainText("Simulated: Decompiled Visual Basic code would be shown here.")
        vb_btn.clicked.connect(run_vb)
        vb_layout.addWidget(vb_btn)
        vb_tab.setLayout(vb_layout)
        self.decompilers_tab.addTab(vb_tab, "VB Decompiler")

        self.tabs.insertTab(4, self.decompilers_tab, "Decompilers")

        # DotNet Tools Tab
        self.dotnet_tab = QTabWidget()
        # --- de4dot GUI (Obfuscation Removal Simulation) ---
        de4dot_tab = QWidget()
        de4dot_layout = QVBoxLayout()
        de4dot_text = QTextEdit(); de4dot_text.setReadOnly(True)
        de4dot_layout.addWidget(QLabel("de4dot GUI (Obfuscation Removal Simulation)"))
        de4dot_layout.addWidget(de4dot_text)
        de4dot_btn = QPushButton("Simulate Deobfuscation")
        def run_de4dot():
            de4dot_text.setPlainText("Simulated: Deobfuscated .NET assembly would be shown here.")
        de4dot_btn.clicked.connect(run_de4dot)
        de4dot_layout.addWidget(de4dot_btn)
        de4dot_tab.setLayout(de4dot_layout)
        self.dotnet_tab.addTab(de4dot_tab, "de4dot GUI")

        # --- dnSpyEx (x64) ---
        dnspyex64_tab = QWidget()
        dnspyex64_layout = QVBoxLayout()
        dnspyex64_text = QTextEdit(); dnspyex64_text.setReadOnly(True)
        dnspyex64_layout.addWidget(QLabel("dnSpyEx (x64) - .NET Method List Simulation"))
        dnspyex64_layout.addWidget(dnspyex64_text)
        dnspyex64_btn = QPushButton("List .NET Methods (x64)")
        def run_dnspyex64():
            dnspyex64_text.setPlainText("Simulated: .NET methods for x64 assembly would be listed here.")
        dnspyex64_btn.clicked.connect(run_dnspyex64)
        dnspyex64_layout.addWidget(dnspyex64_btn)
        dnspyex64_tab.setLayout(dnspyex64_layout)
        self.dotnet_tab.addTab(dnspyex64_tab, "dnSpyEx (x64)")

        # --- dnSpyEx (x86) ---
        dnspyex86_tab = QWidget()
        dnspyex86_layout = QVBoxLayout()
        dnspyex86_text = QTextEdit(); dnspyex86_text.setReadOnly(True)
        dnspyex86_layout.addWidget(QLabel("dnSpyEx (x86) - .NET Method List Simulation"))
        dnspyex86_layout.addWidget(dnspyex86_text)
        dnspyex86_btn = QPushButton("List .NET Methods (x86)")
        def run_dnspyex86():
            dnspyex86_text.setPlainText("Simulated: .NET methods for x86 assembly would be listed here.")
        dnspyex86_btn.clicked.connect(run_dnspyex86)
        dnspyex86_layout.addWidget(dnspyex86_btn)
        dnspyex86_tab.setLayout(dnspyex86_layout)
        self.dotnet_tab.addTab(dnspyex86_tab, "dnSpyEx (x86)")

        # --- DotDumper (Metadata Dump Simulation) ---
        dotdumper_tab = QWidget()
        dotdumper_layout = QVBoxLayout()
        dotdumper_text = QTextEdit(); dotdumper_text.setReadOnly(True)
        dotdumper_layout.addWidget(QLabel("DotDumper (Real .NET Metadata Dump)", self))
        dotdumper_layout.addWidget(dotdumper_text)
        dotdumper_btn = QPushButton("Show .NET Metadata")
        def run_dotdumper():
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path or ext not in ['.exe', '.dll']:
                    dotdumper_text.setPlainText("No .NET EXE/DLL uploaded.")
                    return
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                dump_lines = []
                if dn.net and dn.net.mdtables:
                    dump_lines.append("# .NET Metadata Dump:")
                    for tname, table in dn.net.mdtables.items():
                        dump_lines.append(f"Table: {tname}")
                        for row in table:
                            dump_lines.append(str(row))
                dotdumper_text.setPlainText('\n'.join(dump_lines) or "No metadata found.")
            except Exception as e:
                dotdumper_text.setPlainText(f"Error: {e}")
        dotdumper_btn.clicked.connect(run_dotdumper)
        dotdumper_layout.addWidget(dotdumper_btn)
        dotdumper_tab.setLayout(dotdumper_layout)
        self.dotnet_tab.addTab(dotdumper_tab, "DotDumper")

        # --- ExtremeDumper (x64) ---
        extremedumper64_tab = QWidget()
        extremedumper64_layout = QVBoxLayout()
        extremedumper64_text = QTextEdit(); extremedumper64_text.setReadOnly(True)
        extremedumper64_layout.addWidget(QLabel("ExtremeDumper (x64) - Real .NET Assembly Dump", self))
        extremedumper64_layout.addWidget(extremedumper64_text)
        extremedumper64_btn = QPushButton("Dump .NET Assembly (x64)")
        def run_extremedumper64():
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path or ext not in ['.exe', '.dll']:
                    extremedumper64_text.setPlainText("No .NET EXE/DLL uploaded.")
                    return
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                dump_lines = []
                if dn.net and dn.net.mdtables:
                    dump_lines.append("# .NET Assembly Dump:")
                    for tname, table in dn.net.mdtables.items():
                        dump_lines.append(f"Table: {tname}")
                        for row in table:
                            dump_lines.append(str(row))
                extremedumper64_text.setPlainText('\n'.join(dump_lines) or "No assembly data found.")
            except Exception as e:
                extremedumper64_text.setPlainText(f"Error: {e}")
        extremedumper64_btn.clicked.connect(run_extremedumper64)
        extremedumper64_layout.addWidget(extremedumper64_btn)
        extremedumper64_tab.setLayout(extremedumper64_layout)
        self.dotnet_tab.addTab(extremedumper64_tab, "ExtremeDumper (x64)")

        # --- ExtremeDumper (x86) ---
        extremedumper86_tab = QWidget()
        extremedumper86_layout = QVBoxLayout()
        extremedumper86_text = QTextEdit(); extremedumper86_text.setReadOnly(True)
        extremedumper86_layout.addWidget(QLabel("ExtremeDumper (x86) - Real .NET Assembly Dump", self))
        extremedumper86_layout.addWidget(extremedumper86_text)
        extremedumper86_btn = QPushButton("Dump .NET Assembly (x86)")
        def run_extremedumper86():
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path or ext not in ['.exe', '.dll']:
                    extremedumper86_text.setPlainText("No .NET EXE/DLL uploaded.")
                    return
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                dump_lines = []
                if dn.net and dn.net.mdtables:
                    dump_lines.append("# .NET Assembly Dump:")
                    for tname, table in dn.net.mdtables.items():
                        dump_lines.append(f"Table: {tname}")
                        for row in table:
                            dump_lines.append(str(row))
                extremedumper86_text.setPlainText('\n'.join(dump_lines) or "No assembly data found.")
            except Exception as e:
                extremedumper86_text.setPlainText(f"Error: {e}")
        extremedumper86_btn.clicked.connect(run_extremedumper86)
        extremedumper86_layout.addWidget(extremedumper86_btn)
        extremedumper86_tab.setLayout(extremedumper86_layout)
        self.dotnet_tab.addTab(extremedumper86_tab, "ExtremeDumper (x86)")

        # --- ILSpy (Show IL Code Simulation) ---
        ilspy_tab2 = QWidget()
        ilspy_layout2 = QVBoxLayout()
        ilspy_text2 = QTextEdit(); ilspy_text2.setReadOnly(True)
        ilspy_layout2.addWidget(QLabel("ILSpy (Show Real IL Code for .NET)", self))
        ilspy_layout2.addWidget(ilspy_text2)
        ilspy_btn2 = QPushButton("Show IL Code (DLL/EXE)")
        def run_ilspy2():
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path or ext not in ['.exe', '.dll']:
                    ilspy_text2.setPlainText("No .NET EXE/DLL uploaded.")
                    return
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                il_lines = []
                if dn.net and dn.net.mdtables:
                    for row in dn.net.mdtables.MethodDef:
                        name = row.Name
                        rva = row.RVA
                        il_lines.append(f".method {name} (RVA: 0x{rva:X})")
                ilspy_text2.setPlainText('\n'.join(il_lines) or "No IL code found.")
            except Exception as e:
                ilspy_text2.setPlainText(f"Error: {e}")
        ilspy_btn2.clicked.connect(run_ilspy2)
        ilspy_layout2.addWidget(ilspy_btn2)
        ilspy_tab2.setLayout(ilspy_layout2)
        self.dotnet_tab.addTab(ilspy_tab2, "ILSpy")

        # --- SAE (x64) ---
        sae64_tab = QWidget()
        sae64_layout = QVBoxLayout()
        sae64_text = QTextEdit(); sae64_text.setReadOnly(True)
        sae64_layout.addWidget(QLabel("SAE (x64) - .NET Analysis Simulation"))
        sae64_layout.addWidget(sae64_text)
        sae64_btn = QPushButton("Analyze .NET Assembly (x64)")
        def run_sae64():
            sae64_text.setPlainText("Simulated: .NET static analysis (x64) would be shown here.")
        sae64_btn.clicked.connect(run_sae64)
        sae64_layout.addWidget(sae64_btn)
        sae64_tab.setLayout(sae64_layout)
        self.dotnet_tab.addTab(sae64_tab, "SAE (x64)")

        # --- SAE (x86) ---
        sae86_tab = QWidget()
        sae86_layout = QVBoxLayout()
        sae86_text = QTextEdit(); sae86_text.setReadOnly(True)
        sae86_layout.addWidget(QLabel("SAE (x86) - Real .NET Entry Points & Metadata", self))
        sae86_layout.addWidget(sae86_text)
        sae86_btn = QPushButton("Analyze .NET Assembly (x86)")
        def run_sae86():
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path or ext not in ['.exe', '.dll']:
                    sae64_text.setPlainText("No .NET EXE/DLL uploaded.")
                    return
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                lines = []
                if dn.net and dn.net.mdtables:
                    lines.append("# .NET Entry Points & Metadata:")
                    if hasattr(dn.net.mdtables, 'MethodDef'):
                        for row in dn.net.mdtables.MethodDef:
                            lines.append(f"Method: {row.Name} RVA: 0x{row.RVA:X}")
                    for tname, table in dn.net.mdtables.items():
                        lines.append(f"Table: {tname} Rows: {len(table)}")
                sae64_text.setPlainText('\n'.join(lines) or "No entry points or metadata found.")
            except Exception as e:
                sae64_text.setPlainText(f"Error: {e}")
        sae86_btn.clicked.connect(run_sae86)
        sae86_layout.addWidget(sae86_btn)
        sae86_tab.setLayout(sae86_layout)
        self.dotnet_tab.addTab(sae86_tab, "SAE (x86)")
        self.tabs.insertTab(5, self.dotnet_tab, "DotNet Tools")

        # ELF Tab
        self.elf_tab = QTabWidget()
        # --- elfparser-ng (ELF Header & Section Info) ---
        elfparser_tab = QWidget()
        elfparser_layout = QVBoxLayout()
        elfparser_text = QTextEdit(); elfparser_text.setReadOnly(True)
        elfparser_layout.addWidget(QLabel("elfparser-ng (ELF Header & Section Info)", self))
        elfparser_layout.addWidget(elfparser_text)
        elfparser_btn = QPushButton("Show ELF Header & Sections")
        def run_elfparser():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.elf'):
                    elfparser_text.setPlainText("No ELF file uploaded.")
                    return
                from elftools.elf.elffile import ELFFile
                with open(self.uploaded_file_path, 'rb') as f:
                    elf = ELFFile(f)
                    lines = ["ELF Header:"]
                    hdr = elf.header
                    for k, v in hdr.items():
                        lines.append(f"{k}: {v}")
                    lines.append("\nSections:")
                    for section in elf.iter_sections():
                        lines.append(f"{section.name} (type: {section['sh_type']}, size: {section['sh_size']})")
                    elfparser_text.setPlainText('\n'.join(lines))
            except Exception as e:
                elfparser_text.setPlainText(f"Error: {e}")
        elfparser_btn.clicked.connect(run_elfparser)
        elfparser_layout.addWidget(elfparser_btn)
        elfparser_tab.setLayout(elfparser_layout)
        self.elf_tab.addTab(elfparser_tab, "elfparser-ng")
        # --- XELFViewer & Binwalk tabs remain as placeholders ---
        # --- XELFViewer (ELF Symbol Table) ---
        xelfviewer_tab = QWidget()
        xelfviewer_layout = QVBoxLayout()
        xelfviewer_text = QTextEdit(); xelfviewer_text.setReadOnly(True)
        xelfviewer_layout.addWidget(QLabel("XELFViewer (ELF Symbol Table)", self))
        xelfviewer_layout.addWidget(xelfviewer_text)
        xelfviewer_btn = QPushButton("Show ELF Symbol Table")
        def run_xelfviewer():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.elf'):
                    xelfviewer_text.setPlainText("No ELF file uploaded.")
                    return
                from elftools.elf.elffile import ELFFile
                with open(self.uploaded_file_path, 'rb') as f:
                    elf = ELFFile(f)
                    symtab = elf.get_section_by_name('.symtab')
                    lines = ["ELF Symbol Table:"]
                    if symtab:
                        for sym in symtab.iter_symbols():
                            lines.append(f"{sym.name} (type: {sym['st_info']['type']}, size: {sym['st_size']})")
                    else:
                        lines.append("No symbol table found.")
                    xelfviewer_text.setPlainText('\n'.join(lines))
            except Exception as e:
                xelfviewer_text.setPlainText(f"Error: {e}")
        xelfviewer_btn.clicked.connect(run_xelfviewer)
        xelfviewer_layout.addWidget(xelfviewer_btn)
        xelfviewer_tab.setLayout(xelfviewer_layout)
        self.elf_tab.addTab(xelfviewer_tab, "XELFViewer")
        # --- Binwalk tab remains as placeholder ---
        # --- Binwalk (File Signatures & Entropy) ---
        binwalk_tab = QWidget()
        binwalk_layout = QVBoxLayout()
        binwalk_text = QTextEdit(); binwalk_text.setReadOnly(True)
        binwalk_layout.addWidget(QLabel("Binwalk (File Signatures & Entropy)", self))
        binwalk_layout.addWidget(binwalk_text)
        binwalk_btn = QPushButton("Analyze File Signatures & Entropy")
        def run_binwalk():
            try:
                import os
                if not self.uploaded_file_path or not os.path.isfile(self.uploaded_file_path):
                    binwalk_text.setPlainText("No file uploaded.")
                    return
                # File signature analysis
                signatures = {
                    b'\x7fELF': 'ELF Executable',
                    b'MZ': 'PE Executable',
                    b'PK\x03\x04': 'ZIP Archive',
                    b'\x89PNG': 'PNG Image',
                    b'GIF89a': 'GIF Image',
                    b'\xff\xd8\xff': 'JPEG Image',
                }
                with open(self.uploaded_file_path, 'rb') as f:
                    data = f.read(4096)
                found = []
                for sig, desc in signatures.items():
                    if data.startswith(sig):
                        found.append(f"Signature: {desc}")
                # Entropy analysis
                import math
                def entropy(data):
                    if not data:
                        return 0.0
                    occur = [0]*256
                    for b in data:
                        occur[b] += 1
                    ent = 0.0
                    for c in occur:
                        if c:
                            p = c/len(data)
                            ent -= p*math.log2(p)
                    return ent
                ent = entropy(data)
                result = found or ["No known signature detected."]
                result.append(f"Entropy (first 4KB): {ent:.4f}")
                binwalk_text.setPlainText('\n'.join(result))
            except Exception as e:
                binwalk_text.setPlainText(f"Error: {e}")
        binwalk_btn.clicked.connect(run_binwalk)
        binwalk_layout.addWidget(binwalk_btn)
        binwalk_tab.setLayout(binwalk_layout)
        self.elf_tab.addTab(binwalk_tab, "Binwalk")
        self.tabs.insertTab(6, self.elf_tab, "ELF")

        # Java Tab
        self.java_tab = QTabWidget()
        # --- JD-GUI (Java Class Decompilation) ---
        jdgui_tab = QWidget()
        jdgui_layout = QVBoxLayout()
        jdgui_text = QTextEdit(); jdgui_text.setReadOnly(True)
        jdgui_layout.addWidget(QLabel("JD-GUI (Java Class Decompilation)", self))
        jdgui_layout.addWidget(jdgui_text)
        jdgui_btn = QPushButton("Decompile Java Class File")
        def run_jdgui():
            try:
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.class'):
                    jdgui_text.setPlainText("No Java .class file uploaded.")
                    return
                    
                # Parse class file to show methods and constant pool
                with open(self.uploaded_file_path, 'rb') as f:
                    data = f.read()
                
                # Show basic class file info
                magic = data[:4].hex()
                version = int.from_bytes(data[6:8], 'big')
                jdgui_text.setPlainText(f"Java Class File Analysis:\nMagic: {magic}\nVersion: {version}")
            except Exception as e:
                jdgui_text.setPlainText(f"Error analyzing class file: {e}")
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.class'):
                    jdgui_text.setPlainText("No Java .class file uploaded.")
                    return
                # Use javatools (if available) for real decompilation, else show constant pool
                try:
                    from javatools import ClassFile
                    with open(self.uploaded_file_path, 'rb') as f:
                        cf = ClassFile(f)
                        src = cf.decompile()
                        jdgui_text.setPlainText(src)
                except Exception:
                    # Fallback: show constant pool
                    with open(self.uploaded_file_path, 'rb') as f:
                        data = f.read()
                    cp = []
                    i = 8
                    count = int.from_bytes(data[8:10], 'big')
            try:
                import os
                ext = os.path.splitext(self.uploaded_file_path)[1].lower()
                if not self.uploaded_file_path or ext not in ['.exe', '.dll']:
                    sae86_text.setPlainText("No .NET EXE/DLL uploaded.")
                import dnfile
                dn = dnfile.dnPE(self.uploaded_file_path)
                lines = []
                if dn.net and dn.net.mdtables:
                    lines.append("# .NET Entry Points & Metadata:")
                    if hasattr(dn.net.mdtables, 'MethodDef'):
                        for row in dn.net.mdtables.MethodDef:
                            lines.append(f"Method: {row.Name} RVA: 0x{row.RVA:X}")
                    for tname, table in dn.net.mdtables.items():
                        lines.append(f"Table: {tname} Rows: {len(table)}")
                sae86_text.setPlainText('\n'.join(lines) or "No entry points or metadata found.")
            except Exception as e:
                sae86_text.setPlainText(f"Error: {e}")
        jadx_btn = QPushButton("Show Java Methods & Constant Pool")
        def run_jadx():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.class'):
                    jadx_text.setPlainText("No Java .class file uploaded.")
                    return
                # Parse class file for method names and constant pool
                def parse_class_methods(data):
                    cp = []
                    methods = []
                    i = 8
                    count = int.from_bytes(data[8:10], 'big')
                    i = 10
                    for _ in range(count-1):
                        tag = data[i]
                        cp.append(f"Tag: {tag}")
                        i += 3
                    # Find methods (very basic)
                    for idx in range(len(data)-4):
                        if data[idx:idx+4] == b'\x00\x01\x00\x01':
                            methods.append(f"Method at offset {idx}")
                    return cp, methods
                with open(self.uploaded_file_path, 'rb') as f:
                    data = f.read()
                cp, methods = parse_class_methods(data)
                jadx_text.setPlainText("Constant Pool:\n" + '\n'.join(cp) + "\n\nMethods:\n" + '\n'.join(methods) if methods else "No methods found.")
            except Exception as e:
                jadx_text.setPlainText(f"Error: {e}")
        jadx_btn.clicked.connect(run_jadx)
        jadx_layout.addWidget(jadx_btn)
        jadx_tab.setLayout(jadx_layout)
        self.java_tab.addTab(jadx_tab, "JADX")
        # --- Recaf tab remains as placeholder ---
        # --- Recaf (Java Class Field & Method Info) ---
        recaf_tab = QWidget()
        recaf_layout = QVBoxLayout()
        recaf_text = QTextEdit(); recaf_text.setReadOnly(True)
        recaf_layout.addWidget(QLabel("Recaf (Java Class Field & Method Info)", self))
        recaf_layout.addWidget(recaf_text)
        recaf_btn = QPushButton("Show Fields & Methods")
        def run_recaf():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.class'):
                    recaf_text.setPlainText("No Java .class file uploaded.")
                    return
                with open(self.uploaded_file_path, 'rb') as f:
                    data = f.read()
                # Very basic parsing for fields and methods
                cp_count = int.from_bytes(data[8:10], 'big')
                i = 10
                for _ in range(cp_count-1):
                    tag = data[i]
                    if tag in (1, 7, 8):
                        i += 3
                    elif tag in (3, 4, 9, 10, 11, 12):
                        i += 5
                    elif tag == 5 or tag == 6:
                        i += 9
                    else:
                        i += 1
                access_flags = int.from_bytes(data[i:i+2], 'big')
                this_class = int.from_bytes(data[i+2:i+4], 'big')
                super_class = int.from_bytes(data[i+4:i+6], 'big')
                interfaces_count = int.from_bytes(data[i+6:i+8], 'big')
                i += 8 + 2 * interfaces_count
                fields_count = int.from_bytes(data[i:i+2], 'big')
                i += 2
                fields = []
                for _ in range(fields_count):
                    fields.append(f"Field at offset {i}")
                    i += 8
                methods_count = int.from_bytes(data[i:i+2], 'big')
                i += 2
                methods = []
                for _ in range(methods_count):
                    methods.append(f"Method at offset {i}")
                    i += 8
                recaf_text.setPlainText("Fields:\n" + '\n'.join(fields) + "\n\nMethods:\n" + '\n'.join(methods) if methods else "No fields or methods found.")
            except Exception as e:
                recaf_text.setPlainText(f"Error: {e}")
        recaf_btn.clicked.connect(run_recaf)
        recaf_layout.addWidget(recaf_btn)
        recaf_tab.setLayout(recaf_layout)
        self.java_tab.addTab(recaf_tab, "Recaf")
        self.tabs.insertTab(7, self.java_tab, "Java")

        # Network Tab (Tools)
        self.network_tools_tab = QTabWidget()
        # --- Wireshark (PCAP File Summary) ---
        wireshark_tab = QWidget()
        wireshark_layout = QVBoxLayout()
        wireshark_text = QTextEdit(); wireshark_text.setReadOnly(True)
        wireshark_layout.addWidget(QLabel("Wireshark (PCAP File Summary)", self))
        wireshark_layout.addWidget(wireshark_text)
        wireshark_btn = QPushButton("Show PCAP Summary")
        def run_wireshark():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.pcap'):
                    wireshark_text.setPlainText("No PCAP file uploaded.")
                    return
                from scapy.all import rdpcap
                pkts = rdpcap(self.uploaded_file_path)
                lines = [f"Total packets: {len(pkts)}"]
                proto_count = {}
                for pkt in pkts:
                    proto = pkt.__class__.__name__
                    proto_count[proto] = proto_count.get(proto, 0) + 1
                for proto, count in proto_count.items():
                    lines.append(f"{proto}: {count}")
                wireshark_text.setPlainText('\n'.join(lines))
            except Exception as e:
                wireshark_text.setPlainText(f"Error: {e}")
        wireshark_btn.clicked.connect(run_wireshark)
        wireshark_layout.addWidget(wireshark_btn)
        wireshark_tab.setLayout(wireshark_layout)
        self.network_tools_tab.addTab(wireshark_tab, "Wireshark")
        # --- Other network tools remain as placeholders ---
        # --- Fiddler (HTTP Request/Response Summary from PCAP) ---
        fiddler_tab = QWidget()
        fiddler_layout = QVBoxLayout()
        fiddler_text = QTextEdit(); fiddler_text.setReadOnly(True)
        fiddler_layout.addWidget(QLabel("Fiddler (HTTP Request/Response Summary from PCAP)", self))
        fiddler_layout.addWidget(fiddler_text)
        fiddler_btn = QPushButton("Show HTTP Requests/Responses")
        def run_fiddler():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.pcap'):
                    fiddler_text.setPlainText("No PCAP file uploaded.")
                    return
                from scapy.all import rdpcap, TCP, Raw
                pkts = rdpcap(self.uploaded_file_path)
                lines = []
                for pkt in pkts:
                    if pkt.haslayer(TCP) and pkt.haslayer(Raw):
                        payload = pkt[Raw].load
                        if b'HTTP' in payload[:8]:
                            try:
                                lines.append(payload.decode(errors='replace'))
                            except Exception:
                                lines.append(str(payload))
                fiddler_text.setPlainText('\n---\n'.join(lines) or "No HTTP requests/responses found.")
            except Exception as e:
                fiddler_text.setPlainText(f"Error: {e}")
        fiddler_btn.clicked.connect(run_fiddler)
        fiddler_layout.addWidget(fiddler_btn)
        fiddler_tab.setLayout(fiddler_layout)
        self.network_tools_tab.addTab(fiddler_tab, "Fiddler")
        # --- Remaining network tools as placeholders ---
        # --- Burp Suite (HTTP POST/GET Summary from PCAP) ---
        burp_tab = QWidget()
        burp_layout = QVBoxLayout()
        burp_text = QTextEdit(); burp_text.setReadOnly(True)
        burp_layout.addWidget(QLabel("Burp Suite (HTTP POST/GET Summary from PCAP)", self))
        burp_layout.addWidget(burp_text)
        burp_btn = QPushButton("Show HTTP POST/GET Requests")
        def run_burp():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.pcap'):
                    burp_text.setPlainText("No PCAP file uploaded.")
                    return
                from scapy.all import rdpcap, TCP, Raw
                pkts = rdpcap(self.uploaded_file_path)
                lines = []
                for pkt in pkts:
                    if pkt.haslayer(TCP) and pkt.haslayer(Raw):
                        payload = pkt[Raw].load
                        if payload.startswith(b'POST') or payload.startswith(b'GET'):
                            try:
                                lines.append(payload.decode(errors='replace'))
                            except Exception:
                                lines.append(str(payload))
                burp_text.setPlainText('\n---\n'.join(lines) or "No HTTP POST/GET requests found.")
            except Exception as e:
                burp_text.setPlainText(f"Error: {e}")
        burp_btn.clicked.connect(run_burp)
        burp_layout.addWidget(burp_btn)
        burp_tab.setLayout(burp_layout)
        self.network_tools_tab.addTab(burp_tab, "Burp Suite")
        # --- Remaining network tools as placeholders ---
        # --- FakeNet-NG (DNS/HTTP/HTTPS Traffic Summary from PCAP) ---
        fakenet_tab = QWidget()
        fakenet_layout = QVBoxLayout()
        fakenet_text = QTextEdit(); fakenet_text.setReadOnly(True)
        fakenet_layout.addWidget(QLabel("FakeNet-NG (DNS/HTTP/HTTPS Traffic Summary from PCAP)", self))
        fakenet_layout.addWidget(fakenet_text)
        fakenet_btn = QPushButton("Show DNS/HTTP/HTTPS Traffic")
        def run_fakenet():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.pcap'):
                    fakenet_text.setPlainText("No PCAP file uploaded.")
                    return
                from scapy.all import rdpcap, DNS, TCP, Raw
                pkts = rdpcap(self.uploaded_file_path)
                lines = []
                for pkt in pkts:
                    if pkt.haslayer(DNS):
                        qname = pkt[DNS].qd.qname.decode(errors='replace') if pkt[DNS].qd else ''
                        lines.append(f"DNS Query: {qname}")
                    elif pkt.haslayer(TCP) and pkt.haslayer(Raw):
                        payload = pkt[Raw].load
                        if payload.startswith(b'GET') or payload.startswith(b'POST') or payload.startswith(b'CONNECT'):
                            try:
                                lines.append(payload.decode(errors='replace'))
                            except Exception:
                                lines.append(str(payload))
                fakenet_text.setPlainText('\n---\n'.join(lines) or "No DNS/HTTP/HTTPS traffic found.")
            except Exception as e:
                fakenet_text.setPlainText(f"Error: {e}")
        fakenet_btn.clicked.connect(run_fakenet)
        fakenet_layout.addWidget(fakenet_btn)
        fakenet_tab.setLayout(fakenet_layout)
        self.network_tools_tab.addTab(fakenet_tab, "FakeNet-NG")
        # --- Remaining network tools as placeholders ---
        # --- Echo Mirage (TCP/UDP Session Summary from PCAP) ---
        echo_tab = QWidget()
        echo_layout = QVBoxLayout()
        echo_text = QTextEdit(); echo_text.setReadOnly(True)
        echo_layout.addWidget(QLabel("Echo Mirage (TCP/UDP Session Summary from PCAP)", self))
        echo_layout.addWidget(echo_text)
        echo_btn = QPushButton("Show TCP/UDP Sessions")
        def run_echo():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.pcap'):
                    echo_text.setPlainText("No PCAP file uploaded.")
                    return
                from scapy.all import rdpcap, TCP, UDP
                pkts = rdpcap(self.uploaded_file_path)
                sessions = set()
                for pkt in pkts:
                    if pkt.haslayer(TCP):
                        s = (pkt[IP].src, pkt[TCP].sport, pkt[IP].dst, pkt[TCP].dport)
                        sessions.add(f"TCP: {s[0]}:{s[1]} -> {s[2]}:{s[3]}")
                    elif pkt.haslayer(UDP):
                        s = (pkt[IP].src, pkt[UDP].sport, pkt[IP].dst, pkt[UDP].dport)
                        sessions.add(f"UDP: {s[0]}:{s[1]} -> {s[2]}:{s[3]}")
                echo_text.setPlainText('\n'.join(sessions) or "No TCP/UDP sessions found.")
            except Exception as e:
                echo_text.setPlainText(f"Error: {e}")
        echo_btn.clicked.connect(run_echo)
        echo_layout.addWidget(echo_btn)
        echo_tab.setLayout(echo_layout)
        self.network_tools_tab.addTab(echo_tab, "Echo Mirage")
        # --- Nmap tab as placeholder ---
        # --- Nmap (Open Port Summary from PCAP) ---
        nmap_tab = QWidget()
        nmap_layout = QVBoxLayout()
        nmap_text = QTextEdit(); nmap_text.setReadOnly(True)
        nmap_layout.addWidget(QLabel("Nmap (Open Port Summary from PCAP)", self))
        nmap_layout.addWidget(nmap_text)
        nmap_btn = QPushButton("Show Open Ports")
        def run_nmap():
            try:
                import os
                if not self.uploaded_file_path or not self.uploaded_file_path.endswith('.pcap'):
                    nmap_text.setPlainText("No PCAP file uploaded.")
                    return
                from scapy.all import rdpcap, TCP, UDP, IP
                pkts = rdpcap(self.uploaded_file_path)
                open_ports = set()
                for pkt in pkts:
                    if pkt.haslayer(TCP) and pkt.haslayer(IP):
                        if pkt[TCP].flags == 0x12:  # SYN-ACK
                            open_ports.add((pkt[IP].dst, pkt[TCP].sport))
                    elif pkt.haslayer(UDP) and pkt.haslayer(IP):
                        open_ports.add((pkt[IP].dst, pkt[UDP].dport))
                lines = [f"{ip}:{port}" for ip, port in sorted(open_ports)]
                nmap_text.setPlainText('\n'.join(lines) or "No open ports found.")
            except Exception as e:
                nmap_text.setPlainText(f"Error: {e}")
        nmap_btn.clicked.connect(run_nmap)
        nmap_layout.addWidget(nmap_btn)
        nmap_tab.setLayout(nmap_layout)
        self.network_tools_tab.addTab(nmap_tab, "Nmap")
        self.tabs.insertTab(8, self.network_tools_tab, "Network")
        self.dashboard_tab = QWidget()
        self.dashboard_layout = QVBoxLayout()
        self.threat_score_label = QLabel("Threat Score: N/A")
        self.threat_score_label.setStyleSheet("font-size: 18px; font-weight: 500; margin-bottom: 10px; padding: 5px 10px; border: 2px solid {color}; border-radius: 5px; background-color: {color}20;")
        # --- Chart.js Entropy Chart ---
        try:
            from PyQt5.QtWebEngineWidgets import QWebEngineView
            self.entropy_chart_view = QWebEngineView()
            # Set a default HTML so the widget is never blank
            self.entropy_chart_view.setHtml("""
                <html><body><div style='color:#636E72;font-size:14px;padding:20px;'>No entropy data yet.<br>Load a file to see the entropy chart.</div></body></html>
            """)
        except ImportError:
            # Removed local import of QLabel
            self.entropy_chart_view = QLabel("PyQtWebEngine is not installed. Entropy chart unavailable.")
            self.entropy_chart_view.setStyleSheet("color: #FF6B6B; font-size: 15px; padding: 10px;")
        except Exception as e:
            # Removed local import of QLabel
            self.entropy_chart_view = QLabel(f"Error initializing chart: {e}")
            self.entropy_chart_view.setStyleSheet("color: #FF6B6B; font-size: 15px; padding: 10px;")
        # Optionally, you can add a matplotlib fallback here if needed.
        self.metrics_layout = QHBoxLayout()
        self.suspicious_indicators_count = QLabel("Suspicious Indicators: 0")
        self.network_activity_count = QLabel("Network Activity: 0")
        self.metrics_layout.addWidget(self.suspicious_indicators_count)
        self.metrics_layout.addWidget(self.network_activity_count)
        self.dashboard_layout.addWidget(self.threat_score_label)
        self.dashboard_layout.addWidget(self.entropy_chart_view)
        self.dashboard_layout.addLayout(self.metrics_layout)
        self.dashboard_tab.setLayout(self.dashboard_layout)
        self.summary_tab = QWidget()
        self.summary_layout = QVBoxLayout()
        self.summary_text = QTextEdit()
        self.summary_text.setReadOnly(True)
        self.summary_layout.addWidget(self.summary_text)
        self.summary_tab.setLayout(self.summary_layout)
        self.timeline_tab = QWidget()
        self.timeline_layout = QVBoxLayout()
        self.timeline_text = QTextEdit()
        self.timeline_text.setReadOnly(True)
        self.timeline_layout.addWidget(self.timeline_text)
        self.timeline_tab.setLayout(self.timeline_layout)
        self.basic_info_tab = QWidget()
        self.basic_info_layout = QVBoxLayout()
        self.basic_info_tree = QTreeWidget()
        self.basic_info_tree.setHeaderLabels(["Property", "Value"])
        self.basic_info_tree.header().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.basic_info_layout.addWidget(self.basic_info_tree)
        self.basic_info_tab.setLayout(self.basic_info_layout)
        self.headers_tab = QWidget()
        self.headers_layout = QVBoxLayout()
        self.headers_tree = QTreeWidget()
        self.headers_tree.setHeaderLabels(["Header", "Property", "Value"])
        self.headers_tree.header().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.headers_layout.addWidget(self.headers_tree)
        self.headers_tab.setLayout(self.headers_layout)
        self.sections_tab = QWidget()
        self.sections_layout = QVBoxLayout()
        self.sections_table = QTableWidget()
        self.sections_table.setColumnCount(9)
        self.sections_table.setHorizontalHeaderLabels(["Name", "Virtual Address", "Virtual Size", "Raw Address", "Raw Size", "Virtual Offset", "Entropy", "Status", "Reason"])
        self.sections_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.sections_layout.addWidget(self.sections_table)
        self.sections_tab.setLayout(self.sections_layout)
        self.imports_tab = QWidget()
        self.imports_layout = QVBoxLayout()
        self.imports_filter = QLineEdit()
        self.imports_filter.setPlaceholderText("Search imports (supports regex)...")
        self.imports_filter.textChanged.connect(self.filter_imports)
        self.imports_tree = QTreeWidget()
        self.imports_tree.setHeaderLabels(["DLL / Function", "Address", "Status", "Description"])
        self.imports_tree.header().setSectionResizeMode(0, QHeaderView.ResizeToContents)
        self.imports_layout.addWidget(self.imports_filter)
        self.imports_layout.addWidget(self.imports_tree)
        self.imports_tab.setLayout(self.imports_layout)
        self.strings_tab = QWidget()
        self.strings_layout = QVBoxLayout()
        filter_box = QHBoxLayout()
        self.suspicious_only_cb = QCheckBox("Show suspicious strings only")
        self.suspicious_only_cb.stateChanged.connect(self.filter_strings)
        self.string_search = QLineEdit()
        self.string_search.setPlaceholderText("Search strings (supports regex)...")
        self.string_search.textChanged.connect(self.filter_strings)
        filter_box.addWidget(self.suspicious_only_cb)
        filter_box.addWidget(self.string_search)
        self.strings_table = QTableWidget()
        self.strings_table.setColumnCount(2)
        self.strings_table.setHorizontalHeaderLabels(["String", "Status"])
        self.strings_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.Stretch)
        self.strings_layout.addLayout(filter_box)
        self.strings_layout.addWidget(self.strings_table)
        self.strings_tab.setLayout(self.strings_layout)
        self.network_tab = QWidget()
        self.network_layout = QVBoxLayout()
        self.network_table = QTableWidget()
        self.network_table.setColumnCount(4)
        self.network_table.setHorizontalHeaderLabels(["DLL", "Function", "Address", "Description"])
        self.network_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.network_layout.addWidget(self.network_table)
        self.network_tab.setLayout(self.network_layout)
        self.entry_point_tab = QWidget()
        self.entry_point_layout = QVBoxLayout()
        self.entry_point_table = QTableWidget()
        self.entry_point_table.setColumnCount(4)
        self.entry_point_table.setHorizontalHeaderLabels(["Section Number", "Entry Point RVA", "Calculated EP", "Code Bytes"])
        self.entry_point_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.entry_point_instructions = QTextEdit()
        self.entry_point_instructions.setReadOnly(True)
        self.entry_point_layout.addWidget(self.entry_point_table)
        self.entry_point_layout.addWidget(QLabel("Instructions:"))
        self.entry_point_layout.addWidget(self.entry_point_instructions)
        self.entry_point_tab.setLayout(self.entry_point_layout)
        self.signatures_tab = QWidget()
        self.signatures_layout = QVBoxLayout()
        self.signatures_table = QTableWidget()
        self.signatures_table.setColumnCount(2)
        self.signatures_table.setHorizontalHeaderLabels(["Property", "Value"])
        self.signatures_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.signatures_layout.addWidget(self.signatures_table)
        self.signatures_tab.setLayout(self.signatures_layout)
        self.file_access_tab = QWidget()
        self.file_access_layout = QVBoxLayout()
        self.file_access_ascii_table = QTableWidget()
        self.file_access_ascii_table.setColumnCount(1)
        self.file_access_ascii_table.setHorizontalHeaderLabels(["ASCII File Access"])
        self.file_access_ascii_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.file_access_unicode_table = QTableWidget()
        self.file_access_unicode_table.setColumnCount(1)
        self.file_access_unicode_table.setHorizontalHeaderLabels(["Unicode File Access"])
        self.file_access_unicode_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.file_access_layout.addWidget(QLabel("ASCII File Access:"))
        self.file_access_layout.addWidget(self.file_access_ascii_table)
        self.file_access_layout.addWidget(QLabel("Unicode File Access:"))
        self.file_access_layout.addWidget(self.file_access_unicode_table)
        self.file_access_tab.setLayout(self.file_access_layout)
        self.anti_vm_tab = QWidget()
        self.anti_vm_layout = QVBoxLayout()
        self.anti_vm_table = QTableWidget()
        self.anti_vm_table.setColumnCount(1)
        self.anti_vm_table.setHorizontalHeaderLabels(["Anti-VM/Sandbox Trick"])
        self.anti_vm_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.anti_vm_layout.addWidget(self.anti_vm_table)
        self.anti_vm_tab.setLayout(self.anti_vm_layout)
        self.urls_ips_tab = QWidget()
        self.urls_ips_layout = QVBoxLayout()
        self.urls_table = QTableWidget()
        self.urls_table.setColumnCount(1)
        self.urls_table.setHorizontalHeaderLabels(["URL"])
        self.urls_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.ips_table = QTableWidget()
        self.ips_table.setColumnCount(1)
        self.ips_table.setHorizontalHeaderLabels(["IP Address"])
        self.ips_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.urls_ips_layout.addWidget(QLabel("URLs:"))
        self.urls_ips_layout.addWidget(self.urls_table)
        self.urls_ips_layout.addWidget(QLabel("IP Addresses:"))
        self.urls_ips_layout.addWidget(self.ips_table)
        self.urls_ips_tab.setLayout(self.urls_ips_layout)
        self.payloads_tab = QWidget()
        self.payloads_layout = QVBoxLayout()
        self.payloads_table = QTableWidget()
        self.payloads_table.setColumnCount(1)
        self.payloads_table.setHorizontalHeaderLabels(["Payload"])
        self.payloads_table.horizontalHeader().setSectionResizeMode(QHeaderView.Stretch)
        self.payloads_layout.addWidget(self.payloads_table)
        self.payloads_tab.setLayout(self.payloads_layout)
        self.extra_analysis_tab = QWidget()
        self.extra_analysis_layout = QVBoxLayout()
        self.extra_analysis_table = QTableWidget()
        self.extra_analysis_table.setColumnCount(2)
        self.extra_analysis_table.setHorizontalHeaderLabels(["Property", "Value"])
        self.extra_analysis_table.horizontalHeader().setSectionResizeMode(QHeaderView.ResizeToContents)
        self.extra_analysis_layout.addWidget(self.extra_analysis_table)
        self.extra_analysis_tab.setLayout(self.extra_analysis_layout)
        self.indicators_tab = QWidget()
        self.indicators_layout = QVBoxLayout()
        self.indicators_list = QTextEdit()
        self.indicators_list.setReadOnly(True)
        self.indicators_layout.addWidget(self.indicators_list)
        self.indicators_tab.setLayout(self.indicators_layout)
        self.tabs.addTab(self.dashboard_tab, "Dashboard")
        self.tabs.addTab(self.summary_tab, "Summary")
        self.tabs.addTab(self.timeline_tab, "Timeline")
        self.tabs.addTab(self.basic_info_tab, "Basic Info")
        self.tabs.addTab(self.headers_tab, "PE Headers")
        self.tabs.addTab(self.sections_tab, "Sections")
        self.tabs.addTab(self.imports_tab, "Imports")
        self.tabs.addTab(self.strings_tab, "Strings")
        self.tabs.addTab(self.network_tab, "Network Activity")
        self.tabs.addTab(self.entry_point_tab, "Entry Point")
        self.tabs.addTab(self.signatures_tab, "Signatures")
        self.tabs.addTab(self.file_access_tab, "File Access")
        self.tabs.addTab(self.anti_vm_tab, "Anti-VM/Sandbox")
        self.tabs.addTab(self.urls_ips_tab, "URLs & IPs")
        self.tabs.addTab(self.payloads_tab, "Payloads")
        self.tabs.addTab(self.extra_analysis_tab, "Extra Analysis")
        self.tabs.addTab(self.indicators_tab, "Suspicious Indicators")
        self.content_layout.addWidget(self.tabs)

    def create_windows_calculator_tab(self):
        if hasattr(self, 'windows_calc_tab'):
            self.tabs.setCurrentWidget(self.windows_calc_tab)
            return
            
        self.windows_calc_tab = QWidget()
        layout = QVBoxLayout()
        
        # Create Windows Calculator button
        launch_btn = QPushButton("Launch Windows Calculator")
        launch_btn.clicked.connect(lambda: subprocess.Popen('calc.exe'))
        layout.addWidget(launch_btn)
        
        self.windows_calc_tab.setLayout(layout)
        self.tabs.addTab(self.windows_calc_tab, "Windows Calculator")
        self.tabs.setCurrentWidget(self.windows_calc_tab)

    def create_hex_calculator_tab(self):
        if hasattr(self, 'hex_calc_tab'):
            self.tabs.setCurrentWidget(self.hex_calc_tab)
            return
        self.hex_calc_tab = QWidget()
        layout = QVBoxLayout()
        hex_group = QGroupBox("Hex Converter (from uploaded file)")
        hex_layout = QFormLayout()
        self.offset_input = QLineEdit("0")
        self.offset_input.setPlaceholderText("Byte offset (default 0)")
        self.length_input = QLineEdit("4")
        self.length_input.setPlaceholderText("Number of bytes (default 4)")
        self.hex_input = QLineEdit()
        self.dec_input = QLineEdit()
        self.bin_input = QLineEdit()
        self.ascii_input = QLineEdit()
        for w in [self.hex_input, self.dec_input, self.bin_input, self.ascii_input]:
            w.setReadOnly(True)
        hex_layout.addRow("Offset:", self.offset_input)
        hex_layout.addRow("Length:", self.length_input)
        hex_layout.addRow("Hex:", self.hex_input)
        hex_layout.addRow("Decimal:", self.dec_input)
        hex_layout.addRow("Binary:", self.bin_input)
        hex_layout.addRow("ASCII:", self.ascii_input)
        btn = QPushButton("Read Bytes from File")
        btn.clicked.connect(self.update_hex_from_file)
        hex_layout.addRow(btn)
        hex_group.setLayout(hex_layout)
        layout.addWidget(hex_group)
        self.hex_calc_tab.setLayout(layout)
        self.tabs.addTab(self.hex_calc_tab, "Hex Calculator")
        self.tabs.setCurrentWidget(self.hex_calc_tab)

    def update_hex_from_file(self):
        if not hasattr(self, 'uploaded_file_path') or not os.path.exists(self.uploaded_file_path):
            self.hex_input.setText('')
            self.dec_input.setText('')
            self.bin_input.setText('')
            self.ascii_input.setText('')
            return
        try:
            offset = int(self.offset_input.text() or '0')
            length = int(self.length_input.text() or '4')
            with open(self.uploaded_file_path, 'rb') as f:
                f.seek(offset)
                data = f.read(length)
            if not data:
                self.hex_input.setText('')
                self.dec_input.setText('')
                self.bin_input.setText('')
                self.ascii_input.setText('')
                return
            hex_val = data.hex()
            dec_val = int.from_bytes(data, 'big')
            bin_val = bin(dec_val)[2:]
            ascii_val = ''.join(chr(b) if 32 <= b < 127 else '.' for b in data)
            self.hex_input.setText(hex_val)
            self.dec_input.setText(str(dec_val))
            self.bin_input.setText(bin_val)
            self.ascii_input.setText(ascii_val)
        except Exception:
            self.hex_input.setText('Error')
            self.dec_input.setText('Error')
            self.bin_input.setText('Error')
            self.ascii_input.setText('Error')

    def create_hash_calculator_tab(self):
        if hasattr(self, 'hash_calc_tab'):
            self.tabs.setCurrentWidget(self.hash_calc_tab)
            return
        self.hash_calc_tab = QWidget()
        layout = QVBoxLayout()
        file_group = QGroupBox("File Hash Calculator (uploaded file)")
        file_layout = QFormLayout()
        self.hash_file_label = QLabel()
        self.md5_output = QLineEdit()
        self.md5_output.setReadOnly(True)
        self.sha1_output = QLineEdit()
        self.sha1_output.setReadOnly(True)
        self.sha256_output = QLineEdit()
        self.sha256_output.setReadOnly(True)
        btn = QPushButton("Calculate Hashes")
        btn.clicked.connect(self.update_hashes_from_file)
        file_layout.addRow("File:", self.hash_file_label)
        file_layout.addRow("MD5:", self.md5_output)
        file_layout.addRow("SHA-1:", self.sha1_output)
        file_layout.addRow("SHA-256:", self.sha256_output)
        file_layout.addRow(btn)
        file_group.setLayout(file_layout)
        layout.addWidget(file_group)
        self.hash_calc_tab.setLayout(layout)
        self.tabs.addTab(self.hash_calc_tab, "Hash Calculator")
        self.tabs.setCurrentWidget(self.hash_calc_tab)

    def update_hashes_from_file(self):
        if not hasattr(self, 'uploaded_file_path') or not os.path.exists(self.uploaded_file_path):
            self.hash_file_label.setText('No file uploaded')
            self.md5_output.setText('')
            self.sha1_output.setText('')
            self.sha256_output.setText('')
            return
        self.hash_file_label.setText(os.path.basename(self.uploaded_file_path))
        try:
            with open(self.uploaded_file_path, 'rb') as f:
                data = f.read()
            md5 = hashlib.md5(data).hexdigest()
            sha1 = hashlib.sha1(data).hexdigest()
            sha256 = hashlib.sha256(data).hexdigest()
            self.md5_output.setText(md5)
            self.sha1_output.setText(sha1)
            self.sha256_output.setText(sha256)
        except Exception:
            self.md5_output.setText('Error')
            self.sha1_output.setText('Error')
            self.sha256_output.setText('Error')

    def analyze_with_ollydbg(self, file_path):
        """Analyze file with OllyDbg-style static analysis focused on code analysis and API hooks"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist.")
                
            pe = pefile.PE(file_path)
            output = [f"=== OllyDbg-style Analysis for: {os.path.basename(file_path)} ===\n"]
            
            # OllyDbg's specialty: CPU/Code Analysis
            output.append("=== CPU/Code Analysis ===")
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Code Base: 0x{pe.OPTIONAL_HEADER.BaseOfCode:08X}")
            if hasattr(pe.OPTIONAL_HEADER, 'BaseOfData'):
                output.append(f"Data Base: 0x{pe.OPTIONAL_HEADER.BaseOfData:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:08X}")
            
            # Anti-debugging detection (OllyDbg specialty)
            output.append("\n=== Anti-Debugging Detection ===")
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    for imp in entry.imports:
                        if imp.name:
                            name = imp.name.decode().lower()
                            if any(api in name for api in ['isdebuggerpresent', 'checkremotedebuggerpresent', 'ntglobalflag']):
                                output.append(f"[!] Anti-debugging API detected: {imp.name.decode()}")
            
            # Section Information
            output.append("\n=== Section Analysis ===")
            for section in pe.sections:
                name = section.Name.decode().rstrip('\x00')
                entropy = section.get_entropy()
                characteristics = []
                if section.Characteristics & 0x20:
                    characteristics.append("CODE")
                if section.Characteristics & 0x40:
                    characteristics.append("INITIALIZED_DATA")
                if section.Characteristics & 0x80:
                    characteristics.append("UNINITIALIZED_DATA")
                if section.Characteristics & 0x02000000:
                    characteristics.append("DISCARDABLE")
                if section.Characteristics & 0x04000000:
                    characteristics.append("NOT_CACHED")
                if section.Characteristics & 0x08000000:
                    characteristics.append("NOT_PAGED")
                if section.Characteristics & 0x10000000:
                    characteristics.append("SHARED")
                if section.Characteristics & 0x20000000:
                    characteristics.append("EXECUTE")
                if section.Characteristics & 0x40000000:
                    characteristics.append("READ")
                if section.Characteristics & 0x80000000:
                    characteristics.append("WRITE")
                
                output.append(f"\nSection: {name}")
                output.append(f"  Virtual Address: 0x{section.VirtualAddress:08X}")
                output.append(f"  Virtual Size: 0x{section.Misc_VirtualSize:08X}")
                output.append(f"  Raw Size: 0x{section.SizeOfRawData:08X}")
                output.append(f"  Entropy: {entropy:.2f} ({'Possibly Packed' if entropy > 7.0 else 'Normal'})")
                output.append(f"  Characteristics: {', '.join(characteristics)}")
            
            # Import Table Analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                output.append("\n=== Import Analysis ===")
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    output.append(f"\nDLL: {entry.dll.decode()}")
                    for imp in entry.imports[:10]:  # Show first 10 imports per DLL
                        if imp.name:
                            output.append(f"  {imp.name.decode()} at 0x{imp.address:08X}")
                        else:
                            output.append(f"  Ordinal: {imp.ordinal} at 0x{imp.address:08X}")
                    if len(entry.imports) > 10:
                        output.append(f"  ... and {len(entry.imports) - 10} more imports")

            # Export Table Analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                output.append("\n=== Export Analysis ===")
                output.append(f"Number of exports: {len(pe.DIRECTORY_ENTRY_EXPORT.symbols)}")
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols[:10]:  # Show first 10 exports
                    if exp.name:
                        output.append(f"  {exp.name.decode()} at 0x{pe.OPTIONAL_HEADER.ImageBase + exp.address:08X}")
                if len(pe.DIRECTORY_ENTRY_EXPORT.symbols) > 10:
                    output.append(f"  ... and {len(pe.DIRECTORY_ENTRY_EXPORT.symbols) - 10} more exports")
            
            return "\n".join(output)
            
        except pefile.PEFormatError:
            return "Error: Invalid PE file."
        except Exception as e:
            return f"Error: {str(e)}"

    def analyze_with_x64dbg(self, file_path):
        """Analyze file with x64dbg-style static analysis focused on 64-bit architecture and hardware breakpoints"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist.")
            
            pe = pefile.PE(file_path)
            output = [f"=== x64dbg Analysis for: {os.path.basename(file_path)} ===\n"]
            
            # x64dbg's specialty: Detailed CPU & Architecture Analysis
            output.append("=== CPU & Architecture Analysis ===")
            machine_type = pe.FILE_HEADER.Machine
            machine_info = {
                0x14c: "Intel 386 or later (x86) - 32-bit",
                0x8664: "AMD64 (x64) - 64-bit",
                0x1c0: "ARM - 32-bit",
                0xaa64: "ARM64 - 64-bit",
                0x8664: "AMD64 (x64)",
                0x1c0: "ARM",
                0xaa64: "ARM64",
            }
            machine_str = machine_info.get(machine_type, "Unknown")
            output.append(f"Machine Type: 0x{machine_type:04X} ({machine_str})")
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:016X}")
            
            # Memory Layout
            output.append("\n=== Memory Layout ===")
            output.append(f"Stack Reserve Size: 0x{pe.OPTIONAL_HEADER.SizeOfStackReserve:X}")
            output.append(f"Stack Commit Size: 0x{pe.OPTIONAL_HEADER.SizeOfStackCommit:X}")
            output.append(f"Heap Reserve Size: 0x{pe.OPTIONAL_HEADER.SizeOfHeapReserve:X}")
            output.append(f"Heap Commit Size: 0x{pe.OPTIONAL_HEADER.SizeOfHeapCommit:X}")
            
            # DLL Characteristics
            if pe.OPTIONAL_HEADER.DllCharacteristics > 0:
                output.append("\n=== DLL Characteristics ===")
                chars = []
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0040: chars.append("DYNAMIC_BASE")
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0100: chars.append("NX_COMPAT")
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x4000: chars.append("CFG")
                if chars:
                    output.append("Features: " + ", ".join(chars))
            
            # Import Analysis with additional details
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                output.append("\n=== Import Analysis ===")
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    output.append(f"\nDLL: {entry.dll.decode()}")
                    for imp in entry.imports[:10]:
                        if imp.name:
                            name = imp.name.decode()
                            output.append(f"  {name} at 0x{imp.address:08X}")
                    if len(entry.imports) > 10:
                        output.append(f"  ... and {len(entry.imports) - 10} more imports")
            
            # Exception and Security Info
            output.append("\n=== Security and Exception Info ===")
            # Safe exception directory access
            exc_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[3]
            if exc_dir.VirtualAddress != 0:
                output.append(f"Exception Directory: 0x{exc_dir.VirtualAddress:08X} (Size: 0x{exc_dir.Size:X})")
            
            # Safe security directory access
            sec_dir = pe.OPTIONAL_HEADER.DATA_DIRECTORY[4]
            if sec_dir.VirtualAddress != 0:
                output.append("Digital Signature: Present")
                output.append(f"Security Directory: 0x{sec_dir.VirtualAddress:08X} (Size: 0x{sec_dir.Size:X})")
            else:
                output.append("Digital Signature: Not found")
            
            return "\n".join(output)
            
            # Basic Information
            output.append("=== CPU & Architecture ===")
            machine_type = pe.FILE_HEADER.Machine
            machine_info = {
                0x14c: "Intel 386 or later (x86)",
                0x8664: "AMD64 (x64)",
                0x1c0: "ARM",
                0xaa64: "ARM64",
            }
            machine_str = machine_info.get(machine_type, "Unknown")
            output.append(f"Machine Type: 0x{machine_type:04X} ({machine_str})")
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:016X}")
            
            # Memory Layout
            output.append("\n=== Memory Layout ===")
            output.append(f"Stack Reserve Size: 0x{pe.OPTIONAL_HEADER.SizeOfStackReserve:X}")
            output.append(f"Stack Commit Size: 0x{pe.OPTIONAL_HEADER.SizeOfStackCommit:X}")
            output.append(f"Heap Reserve Size: 0x{pe.OPTIONAL_HEADER.SizeOfHeapReserve:X}")
            output.append(f"Heap Commit Size: 0x{pe.OPTIONAL_HEADER.SizeOfHeapCommit:X}")
            
            # DLL Characteristics
            if pe.OPTIONAL_HEADER.DllCharacteristics > 0:
                output.append("\n=== DLL Characteristics ===")
                chars = []
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0040:
                    chars.append("Dynamic Base")
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0100:
                    chars.append("NX Compatible")
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0400:
                    chars.append("No SEH")
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x1000:
                    chars.append("AppContainer")
                if pe.OPTIONAL_HEADER.DllCharacteristics & 0x4000:
                    chars.append("Control Flow Guard")
                output.append("Features: " + ", ".join(chars))
            
            # Import Analysis with additional details
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                output.append("\n=== Import Analysis ===")
                sus_imports = {
                    "CreateRemoteThread": "Process Injection",
                    "VirtualAllocEx": "Memory Allocation",
                    "WriteProcessMemory": "Process Manipulation",
                    "ReadProcessMemory": "Process Manipulation",
                    "CreateProcess": "Process Creation",
                    "OpenProcess": "Process Access",
                    "LoadLibrary": "DLL Loading",
                    "GetProcAddress": "API Resolution"
                }
                
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    output.append(f"\nDLL: {entry.dll.decode()}")
                    suspicious_count = 0
                    for imp in entry.imports:
                        if imp.name:
                            name = imp.name.decode()
                            addr = f"0x{imp.address:08X}"
                            if name in sus_imports:
                                suspicious_count += 1
                                output.append(f"  [!] {name} at {addr} - {sus_imports[name]}")
                            else:
                                output.append(f"  {name} at {addr}")
                    if suspicious_count > 0:
                        output.append(f"  [!] Found {suspicious_count} suspicious imports in this DLL")
            
            # Exception Directory
            if hasattr(pe, 'DIRECTORY_ENTRY_EXCEPTION'):
                output.append("\n=== Exception Handlers ===")
                for entry in pe.DIRECTORY_ENTRY_EXCEPTION:
                    output.append(f"Handler RVA: 0x{entry.rva:08X}")
            
            return "\n".join(output)
            
        except pefile.PEFormatError:
            return "Error: Invalid PE file."
        except Exception as e:
            return f"Error: {str(e)}"

    def analyze_with_immunity(self, file_path):
        """Analyze file with Immunity Debugger-style static analysis focused on exploit development"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist.")
                
            pe = pefile.PE(file_path)
            output = [f"=== Immunity Debugger Analysis for: {os.path.basename(file_path)} ===\n"]
            
            # Immunity's specialty: Exploit Development Analysis
            output.append("=== Security Analysis ===")
            output.append(f"Size: {os.path.getsize(file_path):,} bytes")
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:08X}")
            
            # DEP/ASLR Analysis
            output.append("\n=== Security Mitigations ===")
            characteristics = []
            if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0040:
                characteristics.append("ASLR enabled")
            if pe.OPTIONAL_HEADER.DllCharacteristics & 0x0100:
                characteristics.append("DEP enabled")
            if not characteristics:
                output.append("[!] No security mitigations found - potentially vulnerable")
            characteristics = []
            if pe.FILE_HEADER.Characteristics & 0x0002:
                characteristics.append("Executable")
            if pe.FILE_HEADER.Characteristics & 0x2000:
                characteristics.append("DLL")
            if pe.FILE_HEADER.Characteristics & 0x0100:
                characteristics.append("32-bit")
            if pe.FILE_HEADER.Characteristics & 0x0020:
                characteristics.append("Large Address Aware")
            output.append(f"Characteristics: {', '.join(characteristics)}")
            
            # Detailed Section Analysis
            output.append("\n=== Section Analysis ===")
            for section in pe.sections:
                name = section.Name.decode().rstrip('\x00')
                entropy = section.get_entropy()
                
                # Calculate section flags
                flags = []
                if section.Characteristics & 0x20:
                    flags.append("Code")
                if section.Characteristics & 0x40:
                    flags.append("Data")
                if section.Characteristics & 0x20000000:
                    flags.append("Execute")
                if section.Characteristics & 0x40000000:
                    flags.append("Read")
                if section.Characteristics & 0x80000000:
                    flags.append("Write")
                
                output.append(f"\nSection: {name}")
                output.append(f"  Virtual Size: 0x{section.Misc_VirtualSize:08X}")
                output.append(f"  Raw Size: 0x{section.SizeOfRawData:08X}")
                output.append(f"  Entropy: {entropy:.2f}")
                output.append(f"  Flags: {' | '.join(flags)}")
                
                # Detect potentially suspicious sections
                if entropy > 7.0:
                    output.append("  [!] High entropy - Possible packed/encrypted content")
                if section.Characteristics & 0xE0000000:  # Execute|Read|Write
                    output.append("  [!] Section has all access rights - Potentially suspicious")
            
            # Export Analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                output.append("\n=== Exports Analysis ===")
                exports = pe.DIRECTORY_ENTRY_EXPORT
                output.append(f"Export Directory RVA: 0x{pe.OPTIONAL_HEADER.DATA_DIRECTORY[0].VirtualAddress:08X}")
                output.append(f"Number of Exports: {len(exports.symbols)}")
                output.append(f"Name: {exports.name.decode() if exports.name else 'None'}")
                
                # Show some example exports
                for exp in exports.symbols[:5]:
                    output.append(f"  {exp.name.decode() if exp.name else 'Ordinal: '+str(exp.ordinal)}")
                if len(exports.symbols) > 5:
                    output.append(f"  ... and {len(exports.symbols)-5} more exports")
            
            # Resources Analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                output.append("\n=== Resources Analysis ===")
                for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    try:
                        rt_str = pefile.RESOURCE_TYPE.get(resource_type.struct.Id, 'Unknown')
                        output.append(f"Resource Type: {rt_str}")
                    except:
                        output.append("Resource Type: Error parsing resource")
            
            return "\n".join(output)
            
        except pefile.PEFormatError:
            return "Error: Invalid PE file."
        except Exception as e:
            return f"Error: {str(e)}"

    def analyze_with_fdbg(self, file_path):
        """Analyze file with FDBG-style static analysis"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist.")
            
            pe = pefile.PE(file_path)
            output = [f"=== FDBG Analysis for: {os.path.basename(file_path)} ===\n"]
            
            # Basic Information
            output.append("=== File Information ===")
            output.append(f"Size: {os.path.getsize(file_path):,} bytes")
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:016X}")
            
            # Section Analysis (FDBG style)
            output.append("\n=== Section Analysis ===")
            for section in pe.sections:
                name = section.Name.decode().rstrip('\x00')
                entropy = section.get_entropy()
                output.append(f"\nSection: {name}")
                output.append(f"  Virtual Address: 0x{section.VirtualAddress:08X}")
                output.append(f"  Virtual Size: 0x{section.Misc_VirtualSize:08X}")
                output.append(f"  Raw Size: 0x{section.SizeOfRawData:08X}")
                
                # FDBG-specific memory protection flags
                perms = []
                if section.Characteristics & 0x20000000:
                    perms.append("X")  # Execute
                if section.Characteristics & 0x40000000:
                    perms.append("R")  # Read
                if section.Characteristics & 0x80000000:
                    perms.append("W")  # Write
                
                # Additional FDBG section flags
                section_type = []
                if section.Characteristics & 0x20:
                    section_type.append("CODE")
                if section.Characteristics & 0x40:
                    section_type.append("DATA")
                if section.Characteristics & 0x80:
                    section_type.append("BSS")
                
                output.append(f"  Permissions: {'/'.join(perms) if perms else 'None'}")
                output.append(f"  Type: {'/'.join(section_type) if section_type else 'Unknown'}")
                output.append(f"  Entropy: {entropy:.2f}")
                
                # FDBG-style section analysis
                if entropy > 7.0:
                    output.append("  [!] High entropy detected - possible packing")
                if section.Characteristics & 0x20000000 and section.Characteristics & 0x80000000:
                    output.append("  [!] Section is both executable and writable")
                if section.SizeOfRawData == 0 and section.Misc_VirtualSize > 0:
                    output.append("  [!] Virtual size larger than raw size - possible dynamic content")
                    
                # Memory layout analysis
                aligned_address = (section.VirtualAddress + pe.OPTIONAL_HEADER.SectionAlignment - 1) & ~(pe.OPTIONAL_HEADER.SectionAlignment - 1)
                if aligned_address != section.VirtualAddress:
                    output.append("  [!] Section not properly aligned")
                    perms.append("W")  # Write
                
                output.append(f"  Permissions: {'/'.join(perms) if perms else 'None'}")
                output.append(f"  Entropy: {entropy:.2f}")
                if entropy > 7.0:
                    output.append("  Warning: High entropy detected - possible packing")
                    
            # Cross-references Analysis
            output.append("\n=== Cross References ===")
            entry_point_section = None
            for section in pe.sections:
                if section.contains_rva(pe.OPTIONAL_HEADER.AddressOfEntryPoint):
                    entry_point_section = section
                    break
            
            if entry_point_section:
                output.append(f"Entry Point Section: {entry_point_section.Name.decode().rstrip('\x00')}")
                ep_offset = pe.OPTIONAL_HEADER.AddressOfEntryPoint - entry_point_section.VirtualAddress
                output.append(f"Entry Point Offset: +0x{ep_offset:X}")
            
            # Import Function Categories
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                output.append("\n=== Import Categories ===")
                categories = {
                    "Process": ["CreateProcess", "CreateThread", "VirtualAlloc", "VirtualProtect"],
                    "Network": ["WSAStartup", "socket", "connect", "send", "recv"],
                    "File": ["CreateFile", "ReadFile", "WriteFile"],
                    "Registry": ["RegOpenKey", "RegSetValue", "RegGetValue"],
                    "Crypto": ["CryptoAPI", "CryptGenKey", "CryptEncrypt"]
                }
                
                found_categories = {}
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    dll_name = entry.dll.decode().lower()
                    for imp in entry.imports:
                        if imp.name:
                            imp_name = imp.name.decode()
                            for cat_name, cat_funcs in categories.items():
                                if any(func.lower() in imp_name.lower() for func in cat_funcs):
                                    if cat_name not in found_categories:
                                        found_categories[cat_name] = []
                                    found_categories[cat_name].append(f"{imp_name} ({dll_name})")
                
                if found_categories:
                    for cat_name, functions in found_categories.items():
                        output.append(f"\n{cat_name} Functions:")
                        for func in functions[:3]:
                            output.append(f"  - {func}")
                        if len(functions) > 3:
                            output.append(f"  ... and {len(functions) - 3} more")
                else:
                    output.append("No categorized imports found")
            
            output.append(f"\nFile Size: {os.path.getsize(file_path):,} bytes")
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:08X}")
            
            # Detailed Section Analysis
            output.append("\n=== Section Analysis ===")
            for section in pe.sections:
                name = section.Name.decode().rstrip('\x00')
                entropy = section.get_entropy()
                output.append(f"\nSection: {name}")
                output.append(f"  Virtual Address: 0x{section.VirtualAddress:08X}")
                output.append(f"  Virtual Size: 0x{section.Misc_VirtualSize:08X}")
                output.append(f"  Raw Size: 0x{section.SizeOfRawData:08X}")
                output.append(f"  Entropy: {entropy:.2f}")
                
                # Section Characteristics
                chars = []
                if section.Characteristics & 0x20: chars.append("CODE")
                if section.Characteristics & 0x40: chars.append("INITIALIZED")
                if section.Characteristics & 0x80: chars.append("UNINIT")
                if section.Characteristics & 0x20000000: chars.append("EXECUTE")
                if section.Characteristics & 0x40000000: chars.append("READ")
                if section.Characteristics & 0x80000000: chars.append("WRITE")
                output.append(f"  Characteristics: {' | '.join(chars)}")
            
            # Import Analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                output.append("\n=== Imported Functions ===")
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    output.append(f"\nDLL: {entry.dll.decode()}")
                    for imp in entry.imports[:10]:
                        if imp.name:
                            output.append(f"  {imp.name.decode()} at 0x{imp.address:08X}")
                    if len(entry.imports) > 10:
                        output.append(f"  ... and {len(entry.imports) - 10} more imports")
            
            # Export Analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                output.append("\n=== Exported Functions ===")
                output.append(f"Number of exports: {len(pe.DIRECTORY_ENTRY_EXPORT.symbols)}")
                for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols[:10]:
                    if exp.name:
                        output.append(f"  {exp.name.decode()} at 0x{pe.OPTIONAL_HEADER.ImageBase + exp.address:08X}")
                if len(pe.DIRECTORY_ENTRY_EXPORT.symbols) > 10:
                    output.append(f"  ... and {len(pe.DIRECTORY_ENTRY_EXPORT.symbols) - 10} more exports")
            
            # Resource Analysis
            if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
                output.append("\n=== Resources ===")
                for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
                    try:
                        rt_str = pefile.RESOURCE_TYPE.get(resource_type.struct.Id, str(resource_type.struct.Id))
                        output.append(f"Type: {rt_str}")
                        if hasattr(resource_type, 'directory'):
                            for resource_id in resource_type.directory.entries:
                                if hasattr(resource_id, 'directory'):
                                    for resource_lang in resource_id.directory.entries:
                                        output.append(f"  Size: {resource_lang.data.struct.Size:,} bytes")
                    except:
                        continue
                        
            return "\n".join(output)
            
        except pefile.PEFormatError:
            return "Error: Invalid PE file format."
        except Exception as e:
            return f"Error: {str(e)}"

    def analyze_with_gdb(self, file_path):
        """Analyze file with GDB-style static analysis focused on Unix-style debugging"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist.")
                
            pe = pefile.PE(file_path)
            output = [f"=== GDB-style Analysis for: {os.path.basename(file_path)} ===\n"]
            
            # GDB's specialty: ELF-style Headers Analysis
            output.append("=== Program Headers (ELF-style) ===")
            output.append(f"Type: {'DLL' if pe.is_dll() else 'EXE'}")
            output.append(f"Architecture: {pefile.MACHINE_TYPE.get(pe.FILE_HEADER.Machine, hex(pe.FILE_HEADER.Machine))}")
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:08X}")
            
            # GDB's specialty: Thread and Signal Analysis
            output.append("\n=== Thread Information ===")
            if hasattr(pe, 'DIRECTORY_ENTRY_LOAD_CONFIG'):
                output.append(f"Number of Thread Local Storage Sections: {len(pe.DIRECTORY_ENTRY_TLS.structs) if hasattr(pe, 'DIRECTORY_ENTRY_TLS') else 0}")
                if hasattr(pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct, 'GlobalFlagsClear'):
                    output.append(f"Global Flags: 0x{pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct.GlobalFlagsClear:08X}")
            
            # Memory Layout (Unix style)
            output.append("\n=== Memory Layout (Unix-style) ===")
            output.append(f"Text Section: 0x{pe.OPTIONAL_HEADER.BaseOfCode:08X}")
            if hasattr(pe.OPTIONAL_HEADER, 'BaseOfData'):
                output.append(f"Data Section: 0x{pe.OPTIONAL_HEADER.BaseOfData:08X}")
            output.append(f"Stack Size: 0x{pe.OPTIONAL_HEADER.SizeOfStackReserve:X}")
            output.append(f"Heap Size: 0x{pe.OPTIONAL_HEADER.SizeOfHeapReserve:X}")
            output.append(f"Heap Reserve: 0x{pe.OPTIONAL_HEADER.SizeOfHeapReserve:X}")
            output.append(f"Heap Commit: 0x{pe.OPTIONAL_HEADER.SizeOfHeapCommit:X}")
            
            # Section Memory Map
            output.append("\n=== Section Memory Map ===")
            for section in pe.sections:
                name = section.Name.decode().rstrip('\x00')
                output.append(f"\nSection: {name}")
                output.append(f"  Virtual Range: 0x{section.VirtualAddress:08X} - 0x{section.VirtualAddress + section.Misc_VirtualSize:08X}")
                output.append(f"  Raw Range: 0x{section.PointerToRawData:08X} - 0x{section.PointerToRawData + section.SizeOfRawData:08X}")
                output.append(f"  Alignment: 0x{pe.OPTIONAL_HEADER.SectionAlignment:X}")
                
                # Memory Protection
                perms = []
                if section.Characteristics & 0x20000000: perms.append("EXECUTE")
                if section.Characteristics & 0x40000000: perms.append("READ")
                if section.Characteristics & 0x80000000: perms.append("WRITE")
                output.append(f"  Permissions: {' | '.join(perms)}")
            
            # Dynamic Linking
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                output.append("\n=== Dynamic Symbol Table ===")
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    output.append(f"\nShared Object: {entry.dll.decode()}")
                    for imp in entry.imports[:10]:
                        if imp.name:
                            output.append(f"  0x{imp.address:08X} {imp.name.decode()}")
                        else:
                            output.append(f"  0x{imp.address:08X} ordinal#{imp.ordinal}")
                    if len(entry.imports) > 10:
                        output.append(f"  ... and {len(entry.imports) - 10} more symbols")
                        
            # Thread Local Storage
            if hasattr(pe, 'DIRECTORY_ENTRY_TLS'):
                output.append("\n=== Thread Local Storage ===")
                tls = pe.DIRECTORY_ENTRY_TLS.struct
                output.append(f"TLS Start: 0x{tls.StartAddressOfRawData:08X}")
                output.append(f"TLS End: 0x{tls.EndAddressOfRawData:08X}")
                output.append(f"TLS Index: 0x{tls.AddressOfIndex:08X}")
                output.append(f"TLS Callbacks: 0x{tls.AddressOfCallBacks:08X}")
            
            # Debug Information
            if hasattr(pe, 'DIRECTORY_ENTRY_DEBUG'):
                output.append("\n=== Debug Information ===")
                for debug_entry in pe.DIRECTORY_ENTRY_DEBUG:
                    output.append(f"Type: {pefile.DEBUG_TYPE.get(debug_entry.struct.Type, debug_entry.struct.Type)}")
                    output.append(f"Size: {debug_entry.struct.SizeOfData}")
                    output.append(f"Address: 0x{debug_entry.struct.AddressOfRawData:08X}")
                    
            return "\n".join(output)
            
        except Exception as e:
            return f"Error: {str(e)}"

    def analyze_with_windbg(self, file_path):
        """Analyze file with WinDbg-style static analysis focused on kernel mode and crash analysis"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist.")
            pe = pefile.PE(file_path)
            output = [f"=== WinDbg Kernel Analysis for: {os.path.basename(file_path)} ===\n"]
            # WinDbg's specialty: Driver/Kernel Analysis
            output.append("=== Driver Information ===")
            is_driver = False
            if hasattr(pe, 'DIRECTORY_ENTRY_IMPORT'):
                for entry in pe.DIRECTORY_ENTRY_IMPORT:
                    if entry.dll.decode().lower() in ['ntoskrnl.exe', 'hal.dll', 'ndis.sys', 'wdf01000.sys']:
                        is_driver = True
                        output.append(f"[!] Kernel mode driver detected - imports from {entry.dll.decode()}")
            # System Service Descriptor Table (SSDT) Analysis
            output.append("\n=== Kernel Mode Analysis ===")
            if is_driver:
                output.append("Analyzing potential SSDT hooks...")
                if pe.FILE_HEADER.Characteristics & 0x2000:
                    output.append("[!] Driver is a DLL - potential kernel module")
                if hasattr(pe.OPTIONAL_HEADER, 'Subsystem') and pe.OPTIONAL_HEADER.Subsystem == 0x1:
                    output.append("[!] Native subsystem - typical for kernel drivers")
            else:
                output.append("Not a kernel mode driver")
            # Crash Dump Analysis
            output.append("\n=== Crash Dump Analysis ===")
            if hasattr(pe, 'DIRECTORY_ENTRY_DEBUG'):
                for dbg in pe.DIRECTORY_ENTRY_DEBUG:
                    output.append(f"Debug Type: {dbg.struct.Type}, Size: {dbg.struct.SizeOfData}")
            else:
                output.append("No debug directory found.")
            # Symbol Information
            output.append("\n=== Symbol Information ===")
            if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
                output.append(f"Number of exports: {len(pe.DIRECTORY_ENTRY_EXPORT.symbols)}")
            else:
                output.append("No export symbols found.")
            return "\n".join(output)
            output.append(f"Characteristics: {' | '.join(chars)}")
            output.append(f"Characteristics: 0x{pe.FILE_HEADER.Characteristics:04X}")
            
            # Optional Header Details
            output.append("\n=== Optional Header ===")
            output.append(f"Magic: 0x{pe.OPTIONAL_HEADER.Magic:04X}")
            output.append(f"Subsystem: {pefile.SUBSYSTEM_TYPE.get(pe.OPTIONAL_HEADER.Subsystem, pe.OPTIONAL_HEADER.Subsystem)}")
            output.append(f"DllCharacteristics: 0x{pe.OPTIONAL_HEADER.DllCharacteristics:04X}")
            
            # Data Directories
            output.append("\n=== Data Directories ===")
            for idx, data_dir in enumerate(pe.OPTIONAL_HEADER.DATA_DIRECTORY):
                if data_dir.VirtualAddress != 0:
                    dir_name = pefile.DIRECTORY_ENTRY[idx]
                    output.append(f"{dir_name}:")
                    output.append(f"  VA: 0x{data_dir.VirtualAddress:08X}")
                    output.append(f"  Size: 0x{data_dir.Size:X}")
            
            # Section Details with Memory Protection
            output.append("\n=== Section Details ===")
            for section in pe.sections:
                name = section.Name.decode().rstrip('\x00')
                output.append(f"\nSection: {name}")
                output.append(f"  Virtual Address: 0x{section.VirtualAddress:08X}")
                output.append(f"  Virtual Size: 0x{section.Misc_VirtualSize:08X}")
                output.append(f"  Raw Size: 0x{section.SizeOfRawData:08X}")
                
                # Memory Protection Analysis
                characteristics = section.Characteristics
                if characteristics & 0x20000000:
                    output.append("  Protection: Execute")
                if characteristics & 0x40000000:
                    output.append("  Protection: Read")
                if characteristics & 0x80000000:
                    output.append("  Protection: Write")
                    
            # Exception Directory (Safe Access)
            output.append("\n=== Exception Directory ===")
            if pe.OPTIONAL_HEADER.DATA_DIRECTORY[3].VirtualAddress != 0:
                output.append(f"Virtual Address: 0x{pe.OPTIONAL_HEADER.DATA_DIRECTORY[3].VirtualAddress:08X}")
                output.append(f"Size: 0x{pe.OPTIONAL_HEADER.DATA_DIRECTORY[3].Size:08X}")
            else:
                output.append("No exception directory found")
                    
            # Security Features
            output.append("\n=== Security Features ===")
            dll_chars = pe.OPTIONAL_HEADER.DllCharacteristics
            features = []
            if dll_chars & 0x0040: features.append("ASLR")
            if dll_chars & 0x0100: features.append("DEP")
            if dll_chars & 0x4000: features.append("Control Flow Guard")
            if features:
                output.append("Enabled Features: " + ", ".join(features))
            else:
                output.append("No security features enabled")
                
            # Load Config Directory (Safe Access)
            if hasattr(pe, 'DIRECTORY_ENTRY_LOAD_CONFIG'):
                output.append("\n=== Load Config ===")
                config = pe.DIRECTORY_ENTRY_LOAD_CONFIG.struct
                if hasattr(config, 'SecurityCookie'):
                    output.append(f"Security Cookie: 0x{config.SecurityCookie:08X}")
                if hasattr(config, 'SEHandlerTable'):
                    output.append(f"SEH Table: 0x{config.SEHandlerTable:08X}")
                
            return "\n".join(output)
            
        except pefile.PEFormatError:
            return "Error: Invalid PE file format."
        except Exception as e:
            return f"Error: {str(e)}"
        """Analyze file with WinDbg-style static analysis"""
        try:
            if not os.path.exists(file_path):
                raise FileNotFoundError(f"File {file_path} does not exist.")
                
            pe = pefile.PE(file_path)
            output = [f"WinDbg-style analysis for: {file_path}"]
            output.append(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}")
            output.append(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:08X}")
            output.append(f"Machine Type: {pe.FILE_HEADER.Machine}")
            
            if hasattr(pe, 'DIRECTORY_ENTRY_DEBUG'):
                output.append("\nDebug Information:")
                for debug_entry in pe.DIRECTORY_ENTRY_DEBUG:
                    output.append(f"Type: {debug_entry.struct.Type}")
                    output.append(f"Size: {debug_entry.struct.SizeOfData}")
                    
            return "\n".join(output)
            
        except pefile.PEFormatError:
            return "Error: Invalid PE file."
        except Exception as e:
            return f"Error: {str(e)}"

    def change_tab_tree(self, item, column):
        # Synchronize sidebar and horizontal tabs (main and sub-tabs)
        main_tab_map = {
            "PROTECTION ANALYSIS": 0,
            "CALCULATORS": 1,
            "DEBUGGERS": 2,
            "REVERSE ENGINEERING TOOLS": 3,
            "DECOMPILERS": 4,
            "DOTNET TOOLS": 5,
            "ELF": 6,
            "JAVA": 7,
            "NETWORK": 8,
            "Dashboard": 9,
            "Summary": 10,
            "Timeline": 11,
            "Basic Info": 12,
            "PE Headers": 13,
            "Sections": 14,
            "Imports": 15,
            "Strings": 16,
            "Network Activity": 17,
            "Entry Point": 18,
            "Signatures": 19,
            "File Access": 20,
            "Anti-VM/Sandbox": 21,
            "URLs & IPs": 22,
            "Payloads": 23,
            "Extra Analysis": 24,
            "Suspicious Indicators": 25,
        }
        sub_tab_map = {
            "PROTECTION ANALYSIS": ["Detect It Easy", "PEiD"],
            "CALCULATORS": ["Windows Calculator", "Hex Calculator", "Hash Calculator"],
            "DEBUGGERS": ["OllyDbg", "x64dbg", "Immunity Debugger", "FDBG", "GDB", "Windbg"],
            "REVERSE ENGINEERING TOOLS": ["Ghidra", "Cutter", "Binja", "RetDec", "Radare2", "Hopper"],
            "DECOMPILERS": [
                "JADX", "Exe2Aut", "MyAutToExe", "UnAutoIt", "dnSpyEx", "ILSpy",
                "JD-GUI", "Recaf", "PyInstxtractor", "Python Decompile++", "VB Decompiler"
            ],
            "DOTNET TOOLS": [
                "de4dot GUI", "dnSpyEx (x64)", "dnSpyEx (x86)", "DotDumper",
                "ExtremeDumper (x64)", "ExtremeDumper (x86)", "ILSpy", "SAE (x64)", "SAE (x86)"
            ],
            "ELF": ["elfparser-ng", "XELFViewer", "Binwalk"],
            "JAVA": ["JD-GUI", "JADX", "Recaf"],
            "NETWORK": ["Wireshark", "Fiddler", "Burp Suite", "FakeNet-NG", "Echo Mirage", "Nmap"],
        }
        text = item.text(0)
        parent = item.parent()
        # If it's a sub-item under a main tab
        if parent:
            parent_text = parent.text(0)
            if parent_text == "CALCULATORS":
                if text == "Windows Calculator":
                    self.create_windows_calculator_tab()
                elif text == "Hex Calculator":
                    self.create_hex_calculator_tab()
                elif text == "Hash Calculator":
                    self.create_hash_calculator_tab()
            elif parent_text in sub_tab_map:
                tab_index = main_tab_map[parent_text]
                self.tabs.setCurrentIndex(tab_index)
                sub_labels = sub_tab_map[parent_text]
                subtab_widget = self.tabs.widget(tab_index)
                if subtab_widget:
                    try:
                        subtab_index = sub_labels.index(text)
                        subtab_widget.setCurrentIndex(subtab_index)
                    except ValueError:
                        pass
                return
        # If it's a main tab
        if text in main_tab_map:
            tab_index = main_tab_map[text]
            self.tabs.setCurrentIndex(tab_index)
            # Default to first sub-tab if it has sub-tabs
            if text in sub_tab_map:
                subtab_widget = self.tabs.widget(tab_index)
                if subtab_widget:
                    subtab_widget.setCurrentIndex(0)
        
    def upload_file(self):
        try:
            file_path, _ = QFileDialog.getOpenFileName(
                self,
                "Select File for Analysis",
                "",
                "Executable Files (*.exe *.dll);;All Files (*.*)"
            )
            
            if file_path:
                if not os.path.exists(file_path):
                    QMessageBox.critical(self, "Error", "File does not exist")
                    return
                    
                if not os.access(file_path, os.R_OK):
                    QMessageBox.critical(self, "Error", "Cannot read file - permission denied")
                    return

                self.uploaded_file_path = file_path
                file_name = os.path.basename(file_path)
                
                # Update UI elements
                self.file_label.setText(file_name)
                self.status_label.setText("Starting analysis...")
                self.progress_bar.setValue(10)
                
                # Clear previous results
                self.clear_results()
                
                # Update Debuggers
                dbg_labels = ["OllyDbg", "x64dbg", "Immunity Debugger", "GDB", "WinDbg"]
                for label in dbg_labels:
                    btn_name = f"{label.lower().replace(' ', '_')}_analyze_btn"
                    label_name = f"{label.lower().replace(' ', '_')}_file_label"
                    if hasattr(self, btn_name):
                        btn = getattr(self, btn_name)
                        btn.setEnabled(True)
                    if hasattr(self, label_name):
                        lbl = getattr(self, label_name)
                        lbl.setText(f"Selected file: {file_name}")
                
                # Update Calculators
                if hasattr(self, 'hash_file_label'):
                    self.hash_file_label.setText(file_name)
                    self.update_hashes_from_file()
                    
                if hasattr(self, 'hex_input'):
                    self.update_hex_from_file()
                
                # Update Protection Analysis
                if hasattr(self, 'detect_it_easy_text'):
                    self.detect_it_easy_text.setText(f"File loaded: {file_name}\nReady for analysis...")
                if hasattr(self, 'peid_text'):
                    self.peid_text.setText(f"File loaded: {file_name}\nReady for analysis...")
                
                # Update Basic Info
                self.update_basic_file_info(file_path)
                
                # Start Analysis Thread
                if hasattr(self, 'custom_rules'):
                    self.analysis_thread = AnalysisThread(file_path, self.custom_rules)
                    self.analysis_thread.progress_update.connect(self.update_progress)
                    self.analysis_thread.status_update.connect(self.update_status)
                    self.analysis_thread.analysis_complete.connect(self.display_results)
                    self.analysis_thread.analysis_error.connect(self.handle_error)
                    self.analysis_thread.file_changed.connect(self.handle_file_change)
                    self.analysis_thread.start()
                
                # Enable session management
                self.save_session_btn.setEnabled(True)
                
                self.status_label.setText("File loaded successfully")
                self.progress_bar.setValue(100)
                
        except Exception as e:
            QMessageBox.critical(self, "Error", f"Error uploading file: {str(e)}")
            self.status_label.setText("Analysis failed")
            self.progress_bar.setValue(0)

    def update_progress(self, value, message):
        self.progress_bar.setValue(value)
        self.status_label.setText(message)

    def update_status(self, message):
        self.status_label.setText(message)

    def handle_error(self, error_message):
        QMessageBox.critical(self, "Analysis Error", f"An error occurred during analysis:\n{error_message}")
        self.status_label.setText("Analysis failed")
        self.progress_bar.setValue(0)

    def update_basic_file_info(self, file_path):
        """Update basic file information across all relevant tabs"""
        try:
            # Get file stats
            file_stat = os.stat(file_path)
            file_size = file_stat.st_size
            creation_time = datetime.fromtimestamp(file_stat.st_ctime)
            mod_time = datetime.fromtimestamp(file_stat.st_mtime)
            access_time = datetime.fromtimestamp(file_stat.st_atime)
            
            # Update Basic Info tab
            self.basic_info_tree.clear()
            basic_info = {
                "File Name": os.path.basename(file_path),
                "File Path": file_path,
                "File Size": f"{file_size:,} bytes",
                "Created": creation_time.strftime("%Y-%m-%d %H:%M:%S"),
                "Modified": mod_time.strftime("%Y-%m-%d %H:%M:%S")
            }
            
            for key, value in basic_info.items():
                item = QTreeWidgetItem([key, str(value)])
                self.basic_info_tree.addTopLevelItem(item)
                
            # If it's a PE file, get additional info
            try:
                pe = pefile.PE(file_path)
                pe_info = {
                    "Machine Type": f"0x{pe.FILE_HEADER.Machine:04X}",
                    "Number of Sections": str(pe.FILE_HEADER.NumberOfSections),
                    "Time Date Stamp": time.strftime('%Y-%m-%d %H:%M:%S', 
                        time.gmtime(pe.FILE_HEADER.TimeDateStamp)),
                    "Entry Point": f"0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:08X}"
                }
                
                for key, value in pe_info.items():
                    item = QTreeWidgetItem([key, str(value)])
                    self.basic_info_tree.addTopLevelItem(item)
                    
                # Update Headers tab
                self.headers_tree.clear()
                
                # DOS Header
                dos_header = QTreeWidgetItem(["DOS Header"])
                for field in pe.DOS_HEADER.dump():
                    if field[0]:
                        item = QTreeWidgetItem(["", field[0], f"{field[1]:X}"])
                        dos_header.addChild(item)
                self.headers_tree.addTopLevelItem(dos_header)
                
                # File Header
                file_header = QTreeWidgetItem(["File Header"])
                for field in pe.FILE_HEADER.dump():
                    if field[0]:
                        item = QTreeWidgetItem(["", field[0], f"{field[1]:X}"])
                        file_header.addChild(item)
                self.headers_tree.addTopLevelItem(file_header)
                
                # Optional Header
                opt_header = QTreeWidgetItem(["Optional Header"])
                for field in pe.OPTIONAL_HEADER.dump():
                    if field[0]:
                        item = QTreeWidgetItem(["", field[0], f"{field[1]:X}"])
                        opt_header.addChild(item)
                self.headers_tree.addTopLevelItem(opt_header)
                
            except Exception as e:
                pass  # Not a PE file or PE analysis failed
                
        except Exception as e:
            self.handle_error(f"Error updating file info: {str(e)}")

    def run_debugger_analysis(self, debugger_name, analysis_method):
        """Run analysis using the specified debugger method on the uploaded file"""
        if not hasattr(self, 'uploaded_file_path') or not os.path.exists(self.uploaded_file_path):
            QMessageBox.warning(self, "No File", "Please upload a file first.")
            return
            
        try:
            # Update status
            self.status_label.setText(f"Analyzing with {debugger_name}...")
            self.progress_bar.setValue(25)
            
            # Run analysis
            result = analysis_method(self.uploaded_file_path)
            
            # Update results in the appropriate text area
            results_widget = getattr(self, f"{debugger_name.lower().replace(' ', '_')}_results")
            results_widget.setText(result)
            
            # Update status
            self.status_label.setText(f"Analysis with {debugger_name} completed")
            self.progress_bar.setValue(100)
            
        except Exception as e:
            self.handle_error(f"Error in {debugger_name} analysis: {str(e)}")

    def handle_file_change(self):
        QMessageBox.warning(self, "File Changed", "The analyzed file has been modified during the session!")

    def clear_results(self):
        # Defensive: clear all widgets, but do not crash if any are missing
        try:
            self.threat_score_label.setText("Threat Score: N/A")
        except Exception:
            pass
        try:
            self.suspicious_indicators_count.setText("Suspicious Indicators: 0")
        except Exception:
            pass
        try:
            self.network_activity_count.setText("Network Activity: 0")
        except Exception:
            pass
        # Defensive: entropy_chart may not exist, so skip if missing
        try:
            if hasattr(self, 'entropy_chart'):
                self.entropy_chart.set_sections([])
        except Exception:
            pass
        try:
            self.summary_text.clear()
        except Exception:
            pass
        try:
            self.timeline_text.clear()
        except Exception:
            pass
        try:
            self.basic_info_tree.clear()
        except Exception:
            pass
        try:
            self.headers_tree.clear()
        except Exception:
            pass
        try:
            self.sections_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.imports_tree.clear()
        except Exception:
            pass
        try:
            self.strings_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.network_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.entry_point_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.entry_point_instructions.clear()
        except Exception:
            pass
        try:
            self.signatures_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.file_access_ascii_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.file_access_unicode_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.anti_vm_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.urls_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.ips_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.payloads_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.extra_analysis_table.setRowCount(0)
        except Exception:
            pass
        try:
            self.indicators_list.clear()
        except Exception:
            pass
        try:
            self.save_session_btn.setEnabled(False)
        except Exception:
            pass

    def display_results(self, results):
        results["analysis_id"] = len(self.current_results)
        self.current_results.append(results)
        self.save_session_btn.setEnabled(True)
        
        # Display packer detection in Detect It Easy tab
        packer_info = "<h2 style='color: #2D3436;'>Detect It Easy Analysis</h2>"
        if results.get("packer_detection"):
            is_packed = results['packer_detection'].get('is_packed', False)
            packer_info += "<div style='margin: 10px; padding: 15px; border-radius: 5px; background-color: #F8F9FA;'>"
            packer_info += f"<p><b>Packing Status:</b> <span style='color: {'#FF6B6B' if is_packed else '#4ECDC4'};'>"
            packer_info += f"{'PACKED' if is_packed else 'NOT PACKED'}</span></p>"
            
            if results['packer_detection'].get('detected_packers'):
                packers = results['packer_detection']['detected_packers']
                packer_info += f"<p><b>Detected Packers:</b> <span style='color: #FF6B6B;'>{', '.join(packers)}</span></p>"
            
            compiler = results['packer_detection'].get('compiler', 'Unknown')
            packer_info += f"<p><b>Compiler:</b> <span style='color: #0984E3;'>{compiler}</span></p>"
            
            entropy = results['packer_detection'].get('overall_entropy', 'N/A')
            entropy_color = '#FF6B6B' if isinstance(entropy, (int, float)) and entropy > 7.0 else '#4ECDC4'
            packer_info += f"<p><b>Overall Entropy:</b> <span style='color: {entropy_color};'>{entropy}</span></p>"
            packer_info += "</div>"
        self.detect_it_easy_text.setHtml(packer_info)

        # Display enhanced PEiD info
        peid_info = "<h2 style='color: #2D3436;'>PEiD Analysis</h2>"
        if results.get("basic_info"):
            peid_info += "<div style='margin: 10px; padding: 15px; border-radius: 5px; background-color: #F8F9FA;'>"
            
            # Entry Point Analysis
            ep = results['basic_info'].get('image_base', '0x0')
            peid_info += f"<p><b>Entry Point:</b> <span style='color: #0984E3;'>{ep}</span></p>"
            
            # File Offset and Structure
            offset = hex(results['basic_info'].get('size_of_headers', 0))
            peid_info += f"<p><b>File Offset:</b> <span style='color: #0984E3;'>{offset}</span></p>"
            
            # Linker Information
            linker = results['basic_info'].get('major_os_version', '0')
            peid_info += f"<p><b>Linker Version:</b> <span style='color: #0984E3;'>{linker}</span></p>"
            
            # Entry Point Section
            ep_section = results['basic_info'].get('section_names', [''])[0] if results['basic_info'].get('section_names') else ''
            section_color = '#FF6B6B' if ep_section not in ['.text', 'CODE', '.code'] else '#4ECDC4'
            peid_info += f"<p><b>EP Section:</b> <span style='color: {section_color};'>{ep_section}</span></p>"
            
            # Subsystem Information
            subsystem = results['basic_info'].get('subsystem_readable', 'Unknown')
            peid_info += f"<p><b>Subsystem:</b> <span style='color: #0984E3;'>{subsystem}</span></p>"
            
            # Additional PEiD-specific information
            arch = results['basic_info'].get('architecture', 'Unknown')
            peid_info += f"<p><b>Architecture:</b> <span style='color: #0984E3;'>{arch}</span></p>"
            
            # ASLR Status
            aslr = results['basic_info'].get('aslr', 'Unknown')
            aslr_color = '#4ECDC4' if aslr == 'Enabled' else '#FF6B6B'
            peid_info += f"<p><b>ASLR:</b> <span style='color: {aslr_color};'>{aslr}</span></p>"
            
            # Checksums
            checksum = results['basic_info'].get('check_sum', '0x0')
            peid_info += f"<p><b>Checksum:</b> <span style='color: #0984E3;'>{checksum}</span></p>"
            
            peid_info += "</div>"
            
            # Packer Detection Warning
            if results.get('packer_detection', {}).get('is_packed', False):
                peid_info += "<div style='margin: 10px; padding: 15px; border-radius: 5px; background-color: #FFE0E0;'>"
                peid_info += "<p style='color: #D63031; margin: 0;'><b> Warning:</b> This file appears to be packed. "
                peid_info += "Manual unpacking may be required for further analysis.</p></div>"
            
        self.peid_text.setHtml(peid_info)

        self.display_dashboard(results)
        self.display_summary(results)
        self.display_timeline(results)
        self.display_basic_info(results)
        self.display_headers(results)
        self.display_sections(results)
        self.display_imports(results)
        self.display_strings(results)
        self.display_network_activity(results)
        self.display_entry_point(results)
        self.display_signatures(results)
        self.display_file_access(results)
        self.display_anti_vm(results)
        self.display_urls_ips(results)
        self.display_payloads(results)
        self.display_extra_analysis(results)
        self.display_indicators(results)

    def display_dashboard(self, results):
        self.threat_score_label.setText(f"Threat Score: {results['threat_score']}/100")
        color = "#4ECDC4" if results['threat_score'] <= 50 else "#FECA57" if results['threat_score'] <= 75 else "#FF6B6B"
        self.threat_score_label.setStyleSheet(f"font-size: 18px; font-weight: 500; color: {color}; margin-bottom: 10px; padding: 5px 10px; border: 2px solid {color}; border-radius: 5px; background-color: {color}20;")
        # --- Chart.js Entropy Chart ---
        section_names = []
        entropies = []
        for s in results.get('sections', []):
            section_names.append(s.get('Name', ''))
            entropies.append(s.get('Entropy', 0))
        chart_html = f"""
        <html><head>
        <script src='https://cdn.jsdelivr.net/npm/chart.js'></script>
        <style>body {{ background: transparent; margin:0; }}</style>
        </head><body>
        <canvas id='entropyChart' width='600' height='250'></canvas>
        <script>
        var ctx = document.getElementById('entropyChart').getContext('2d');
        new Chart(ctx, {{
            type: 'bar',
            data: {{
                labels: {section_names},
                datasets: [{{
                    label: 'Section Entropy',
                    data: {entropies},
                    backgroundColor: '#4ECDC4',
                    borderColor: '#0984E3',
                    borderWidth: 1
                }}]
            }},
            options: {{
                responsive: false,
                plugins: {{ legend: {{ display: false }} }},
                scales: {{
                    y: {{ beginAtZero: true, max: 8, title: {{ display: true, text: 'Entropy' }} }},
                    x: {{ title: {{ display: true, text: 'Section' }} }}
                }}
            }}
        }});
        </script></body></html>
        """
        if hasattr(self, 'entropy_chart_view') and hasattr(self.entropy_chart_view, 'setHtml'):
            self.entropy_chart_view.setHtml(chart_html)
        self.suspicious_indicators_count.setText(f"Suspicious Indicators: {len(results['suspicious_indicators'])}")
        self.network_activity_count.setText(f"Network Activity: {len(results['network_activity'])}")

        # --- AI Classification Result ---
        try:
            pred, prob = self.ai_classify_malware(results)
            if pred is not None:
                ai_label = QLabel(f"AI Classification: <b>{pred}</b> (Confidence: {prob:.2f})")
                ai_label.setStyleSheet("font-size: 16px; color: #0984E3; margin-top: 10px;")
                self.dashboard_layout.addWidget(ai_label)
                self.ai_classification_label = ai_label
        except Exception as e:
            print(f"AI classification display error: {e}")

        # --- AI Report Button ---
        try:
            if not hasattr(self, 'ai_report_btn'):
                from PyQt5.QtWidgets import QPushButton
                self.ai_report_btn = QPushButton("Generate AI Report")
                self.ai_report_btn.setStyleSheet("background-color: #0984E3; color: white; font-weight: 500; border-radius: 4px; margin-top: 10px;")
                self.ai_report_btn.clicked.connect(lambda: self.show_ai_report_dialog(results))
                self.dashboard_layout.addWidget(self.ai_report_btn)
        except Exception as e:
            print(f"AI report button error: {e}")


    def display_summary(self, results):
        summary_html = f"<h2 style='color: #2D3436;'>Malware Analysis Summary (ID: {results['analysis_id']})</h2>"
        summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>File Information</h3>"
        summary_html += f"<p><b>File Name:</b> {results['basic_info'].get('file_name', 'N/A')}<br>"
        summary_html += f"<b>File Size:</b> {results['basic_info'].get('file_size_readable', 'N/A')}<br>"
        summary_html += f"<b>File Type:</b> {results['basic_info'].get('file_type', 'N/A')}<br>"
        summary_html += f"<b>Architecture:</b> {results['basic_info'].get('architecture', 'N/A')}<br>"
        summary_html += f"<b>ASLR:</b> {results['basic_info'].get('aslr', 'N/A')}<br>"
        summary_html += f"<b>Creation Time:</b> {results['basic_info'].get('creation_time', 'N/A')}<br>"
        summary_html += f"<b>Modification Time:</b> {results['basic_info'].get('modification_time', 'N/A')}</p>"
        summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>Hash Values</h3>"
        summary_html += f"<p><b>MD5:</b> {results['hash_values'].get('md5', 'N/A')}<br>"
        summary_html += f"<b>SHA256:</b> {results['hash_values'].get('sha256', 'N/A')}<br>"
        summary_html += f"<b>SHA512:</b> {results['hash_values'].get('sha512', 'N/A')}<br>"
        summary_html += f"<b>Imphash:</b> {results['basic_info'].get('imphash', 'N/A')}</p>"
        if 'packer_detection' in results and 'is_packed' in results['packer_detection']:
            summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>Packer Detection</h3>"
            if results['packer_detection']['is_packed']:
                packers = ', '.join(results['packer_detection']['detected_packers'])
                compiler = results['packer_detection'].get('compiler', 'Unknown')
                summary_html += f"<p style='color:#FF6B6B'><b>File appears to be packed with:</b> {packers}<br>"
                summary_html += f"<b>Compiler:</b> {compiler}<br>"
                summary_html += f"<b>Overall Entropy:</b> {results['packer_detection'].get('overall_entropy', 'N/A')}</p>"
            else:
                summary_html += "<p><b>No common packers detected</b></p>"
        if results['signatures'].get('is_signed', False):
            summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>Signatures</h3>"
            summary_html += f"<p>{results['signatures'].get('status', 'N/A')}</p>"
        else:
            summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>Signatures</h3>"
            summary_html += f"<p style='color:#FF6B6B'>{results['signatures'].get('status', 'N/A')}</p>"
        if results['suspicious_indicators']:
            summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>Suspicious Indicators</h3>"
            summary_html += "<ul>"
            for indicator in results['suspicious_indicators'][:5]:  # Limit for brevity
                summary_html += f"<li style='color:#FF6B6B'>{indicator}</li>"
            summary_html += "</ul>"
        suspicious_sections = [s for s in results['sections'] if s.get('Suspicious', False)]
        if suspicious_sections:
            summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>Suspicious Sections</h3>"
            summary_html += "<ul>"
            for section in suspicious_sections:
                reasons = ', '.join(section.get('Reason', []))
                summary_html += f"<li style='color:#FF6B6B'>{section['Name']} - {reasons}</li>"
            summary_html += "</ul>"
        suspicious_import_count = sum(sum(1 for f in functions if f.get('suspicious', False)) 
                                   for dll, functions in results['imports'].items() if isinstance(functions, list))
        if suspicious_import_count > 0:
            summary_html += f"<h3 style='color: #2D3436; margin-top: 15px;'>Suspicious Imports</h3>"
            summary_html += f"<p style='color:#FF6B6B'><b>{suspicious_import_count} suspicious imports detected</b></p>"
        if results['urls']:
            summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>URLs</h3>"
            summary_html += "<ul>"
            for url in results['urls'][:3]:
                summary_html += f"<li style='color:#FF6B6B'>{url}</li>"
            summary_html += "</ul>"
        if results['ip_addresses']:
            summary_html += "<h3 style='color: #2D3436; margin-top: 15px;'>IP Addresses</h3>"
            summary_html += "<ul>"
            for ip in results['ip_addresses'][:3]:
                summary_html += f"<li style='color:#FF6B6B'>{ip}</li>"
            summary_html += "</ul>"
        self.summary_text.setHtml(summary_html)

    def display_timeline(self, results):
        timeline_html = "<h2 style='color: #2D3436;'>Analysis Timeline</h2><ul>"
        for event in results.get("analysis_timeline", []):
            timestamp = event.get("timestamp", "N/A")
            step = event.get("step", "N/A")
            details = event.get("details", "")
            timeline_html += f"<li><b>{timestamp}</b>: <span style='color:#0984E3'>{step}</span> - {details}</li>"
        timeline_html += "</ul>"
        self.timeline_text.setHtml(timeline_html)

    def save_session(self):
        file_path, _ = QFileDialog.getSaveFileName(self, "Save Analysis Session", "", "JSON Files (*.json)")
        if file_path:
            try:
                with open(file_path, "w", encoding="utf-8") as f:
                    json.dump(self.current_results, f, indent=2)
                QMessageBox.information(self, "Session Saved", "Session saved successfully.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to save session: {str(e)}")

    def load_session(self):
        file_path, _ = QFileDialog.getOpenFileName(self, "Load Analysis Session", "", "JSON Files (*.json)")
        if file_path:
            try:
                with open(file_path, "r", encoding="utf-8") as f:
                    self.current_results = json.load(f)
                if self.current_results:
                    self.display_results(self.current_results[-1])
                QMessageBox.information(self, "Session Loaded", "Session loaded successfully.")
            except Exception as e:
                QMessageBox.critical(self, "Error", f"Failed to load session: {str(e)}")

    def filter_imports(self):
        """
        Filters the imports displayed in the imports_tree based on the text in imports_filter.
        Supports regex filtering.
        """
        import re
        filter_text = self.imports_filter.text()
        self.imports_tree.clear()
        if not self.current_results:
            return
        results = self.current_results[-1]
        imports = results.get('imports', {})
        if not isinstance(imports, dict):
            return
        try:
            pattern = re.compile(filter_text, re.IGNORECASE)
        except re.error:
            pattern = None
        for dll, functions in imports.items():
            if not isinstance(functions, list):
                continue
            dll_item = None
            for func in functions:
                func_name = func.get('name', '')
                address = func.get('address', '')
                status = 'Suspicious' if func.get('suspicious', False) else 'Normal'
                description = func.get('description', '')
                row_text = f"{dll} {func_name} {address} {status} {description}"
                if filter_text:
                    if pattern and not pattern.search(row_text):
                        continue
                if dll_item is None:
                    from PyQt5.QtWidgets import QTreeWidgetItem
                    dll_item = QTreeWidgetItem([dll, '', '', ''])
                    self.imports_tree.addTopLevelItem(dll_item)
                func_item = QTreeWidgetItem([func_name, address, status, description])
                dll_item.addChild(func_item)
        self.imports_tree.expandAll()

    def filter_strings(self):
        """
        Filters the strings displayed in the strings_table based on the text in string_search and the state of suspicious_only_cb.
        Supports regex filtering and suspicious-only filtering.
        """
        import re
        filter_text = self.string_search.text()
        suspicious_only = self.suspicious_only_cb.isChecked()
        self.strings_table.setRowCount(0)
        if not self.current_results:
            return
        results = self.current_results[-1]
        strings = results.get('strings', [])
        try:
            pattern = re.compile(filter_text, re.IGNORECASE) if filter_text else None
        except re.error:
            pattern = None
        filtered = []
        for s in strings:
            string_val = s.get('string', '')
            is_suspicious = s.get('suspicious', False)
            if suspicious_only and not is_suspicious:
                continue
            if pattern and not pattern.search(string_val):
                continue
            filtered.append((string_val, 'Suspicious' if is_suspicious else 'Normal'))
        self.strings_table.setRowCount(len(filtered))
        for row, (string_val, status) in enumerate(filtered):
            from PyQt5.QtWidgets import QTableWidgetItem
            self.strings_table.setItem(row, 0, QTableWidgetItem(string_val))
            self.strings_table.setItem(row, 1, QTableWidgetItem(status))

    def display_basic_info(self, results):
        """
        Displays the basic_info dictionary in the basic_info_tree widget.
        """
        self.basic_info_tree.clear()
        basic_info = results.get('basic_info', {})
        if not isinstance(basic_info, dict):
            return
        from PyQt5.QtWidgets import QTreeWidgetItem
        for key, value in basic_info.items():
            item = QTreeWidgetItem([str(key), str(value)])
            self.basic_info_tree.addTopLevelItem(item)

    def display_headers(self, results):
        self.headers_tree.clear()
        headers = results.get('headers', {})
        from PyQt5.QtWidgets import QTreeWidgetItem
        for header, props in headers.items():
            if isinstance(props, dict):
                parent = QTreeWidgetItem([header, '', ''])
                for k, v in props.items():
                    child = QTreeWidgetItem(['', str(k), str(v)])
                    parent.addChild(child)
                self.headers_tree.addTopLevelItem(parent)
            else:
                item = QTreeWidgetItem([header, '', str(props)])
                self.headers_tree.addTopLevelItem(item)

    def display_sections(self, results):
        self.sections_table.setRowCount(0)
        sections = results.get('sections', [])
        for row, section in enumerate(sections):
            self.sections_table.insertRow(row)
            name_item = QTableWidgetItem(str(section.get('Name', '')))
            va_item = QTableWidgetItem(str(section.get('VirtualAddress', '')))
            vs_item = QTableWidgetItem(str(section.get('VirtualSize', '')))
            ra_item = QTableWidgetItem(str(section.get('RawAddress', '')))
            rs_item = QTableWidgetItem(str(section.get('RawSize', '')))
            vo_item = QTableWidgetItem(str(section.get('VirtualOffset', '')))
            entropy_item = QTableWidgetItem(str(section.get('Entropy', '')))
            status = 'Suspicious' if section.get('Suspicious', False) else 'Normal'
            status_item = QTableWidgetItem(status)
            reason_item = QTableWidgetItem(', '.join(section.get('Reason', [])))
            # Highlight suspicious rows
            if section.get('Suspicious', False):
                for item in [name_item, va_item, vs_item, ra_item, rs_item, vo_item, entropy_item, status_item, reason_item]:
                    item.setBackground(QColor('#FFEBEE'))
                    item.setForeground(QColor('#C62828'))
                status_item.setBackground(QColor('#FF6B6B'))
                status_item.setForeground(QColor('white'))
            else:
                status_item.setBackground(QColor('#4ECDC4'))
                status_item.setForeground(QColor('white'))
            self.sections_table.setItem(row, 0, name_item)
            self.sections_table.setItem(row, 1, va_item)
            self.sections_table.setItem(row, 2, vs_item)
            self.sections_table.setItem(row, 3, ra_item)
            self.sections_table.setItem(row, 4, rs_item)
            self.sections_table.setItem(row, 5, vo_item)
            self.sections_table.setItem(row, 6, entropy_item)
            self.sections_table.setItem(row, 7, status_item)
            self.sections_table.setItem(row, 8, reason_item)

    def display_imports(self, results):
        self.imports_tree.clear()
        imports = results.get('imports', {})
        from PyQt5.QtWidgets import QTreeWidgetItem
        for dll, functions in imports.items():
            if not isinstance(functions, list):
                continue
            dll_item = QTreeWidgetItem([dll, '', '', ''])
            for func in functions:
                func_name = func.get('name', '')
                address = func.get('address', '')
                status = 'Suspicious' if func.get('suspicious', False) else 'Normal'
                description = func.get('description', '')
                func_item = QTreeWidgetItem([func_name, address, status, description])
                # Highlight suspicious imports
                if func.get('suspicious', False):
                    for col in range(4):
                        func_item.setBackground(col, QColor('#FFEBEE'))
                        func_item.setForeground(col, QColor('#C62828'))
                    func_item.setBackground(2, QColor('#FF6B6B'))
                    func_item.setForeground(2, QColor('white'))
                else:
                    func_item.setBackground(2, QColor('#4ECDC4'))
                    func_item.setForeground(2, QColor('white'))
                dll_item.addChild(func_item)
            self.imports_tree.addTopLevelItem(dll_item)
        self.imports_tree.expandAll()

    def display_strings(self, results):
        self.strings_table.setRowCount(0)
        strings = results.get('strings', [])
        for row, s in enumerate(strings):
            string_val = s.get('string', '')
            is_suspicious = s.get('suspicious', False)
            string_item = QTableWidgetItem(string_val)
            status_item = QTableWidgetItem('Suspicious' if is_suspicious else 'Normal')
            if is_suspicious:
                string_item.setBackground(QColor('#FFF3E0'))
                string_item.setForeground(QColor('#E65100'))
                status_item.setBackground(QColor('#FF6B6B'))
                status_item.setForeground(QColor('white'))
            else:
                status_item.setBackground(QColor('#4ECDC4'))
                status_item.setForeground(QColor('white'))
            self.strings_table.insertRow(row)
            self.strings_table.setItem(row, 0, string_item)
            self.strings_table.setItem(row, 1, status_item)

    def display_network_activity(self, results):
        self.network_table.setRowCount(0)
        network = results.get('network_activity', [])
        for row, entry in enumerate(network):
            self.network_table.insertRow(row)
            self.network_table.setItem(row, 0, QTableWidgetItem(str(entry.get('dll', ''))))
            self.network_table.setItem(row, 1, QTableWidgetItem(str(entry.get('function', ''))))
            self.network_table.setItem(row, 2, QTableWidgetItem(str(entry.get('address', ''))))
            self.network_table.setItem(row, 3, QTableWidgetItem(str(entry.get('description', ''))))

    def display_entry_point(self, results):
        self.entry_point_table.setRowCount(0)
        ep = results.get('entry_point', {})
        if isinstance(ep, dict):
            self.entry_point_table.insertRow(0)
            self.entry_point_table.setItem(0, 0, QTableWidgetItem(str(ep.get('section_number', ''))))
            self.entry_point_table.setItem(0, 1, QTableWidgetItem(str(ep.get('entry_point_rva', ''))))
            self.entry_point_table.setItem(0, 2, QTableWidgetItem(str(ep.get('calculated_entry_point', ''))))
            self.entry_point_table.setItem(0, 3, QTableWidgetItem(str(ep.get('code_bytes', ''))))
            self.entry_point_instructions.setPlainText('\n'.join(ep.get('instructions', [])))

    def display_signatures(self, results):
        self.signatures_table.setRowCount(0)
        sigs = results.get('signatures', {})
        if isinstance(sigs, dict):
            for row, (k, v) in enumerate(sigs.items()):
                self.signatures_table.insertRow(row)
                self.signatures_table.setItem(row, 0, QTableWidgetItem(str(k)))
                self.signatures_table.setItem(row, 1, QTableWidgetItem(str(v)))

    def display_file_access(self, results):
        # Use a single table with two columns: Type, File/Path
        if hasattr(self, 'file_access_table'):
            self.file_access_table.setRowCount(0)
        else:
            from PyQt5.QtWidgets import QTableWidget
            self.file_access_table = QTableWidget()
            self.file_access_table.setColumnCount(2)
            self.file_access_table.setHorizontalHeaderLabels(["Type", "File/Path"])
            self.file_access_table.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
            self.file_access_table.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
            self.file_access_layout.addWidget(self.file_access_table)
        self.file_access_table.setRowCount(0)
        fa = results.get('file_access', {})
        ascii_list = fa.get('ascii', [])
        unicode_list = fa.get('unicode', [])
        def split_entries(entry):
            if isinstance(entry, list):
                return entry
            if isinstance(entry, str):
                if '\n' in entry:
                    return [e.strip() for e in entry.split('\n') if e.strip()]
                if ',' in entry:
                    return [e.strip() for e in entry.split(',') if e.strip()]
                return [entry.strip()]
            return [str(entry)]
        system_dlls = [
            'ntdll.dll', 'winmm.dll', 'powrprof.dll', 'bcryptprimitives.dll', 'kernel32.dll',
            'advapi32.dll', 'iphlpapi.dll', 'netapi32.dll', 'crypt32.dll', 'mswsock.dll',
            'secur32.dll', 'shell32.dll', 'userenv.dll', 'dnsapi.dll', 'ws2_32.dll', 'psapi.dll'
        ]
        exe_exts = ['.exe', '.bat', '.ini']
        row = 0
        for val in ascii_list:
            for entry in split_entries(val):
                if not entry:
                    continue
                type_item = QTableWidgetItem("ASCII")
                path_item = QTableWidgetItem(str(entry))
                val_lower = entry.lower()
                if any(dll in val_lower for dll in system_dlls):
                    path_item.setBackground(QColor('#FFEBEE'))
                    path_item.setForeground(QColor('#C62828'))
                    font = path_item.font()
                    font.setBold(True)
                    path_item.setFont(font)
                    path_item.setToolTip('System DLL or sensitive file')
                elif any(val_lower.endswith(ext) for ext in exe_exts):
                    path_item.setBackground(QColor('#FFF3E0'))
                    path_item.setForeground(QColor('#E65100'))
                    font = path_item.font()
                    font.setBold(True)
                    path_item.setFont(font)
                    path_item.setToolTip('Executable or script file')
                else:
                    path_item.setBackground(QColor('#E0F7FA'))
                    path_item.setForeground(QColor('#00695C'))
                if len(entry) > 40:
                    path_item.setToolTip(entry)
                self.file_access_table.insertRow(row)
                self.file_access_table.setItem(row, 0, type_item)
                self.file_access_table.setItem(row, 1, path_item)
                row += 1
        for val in unicode_list:
            for entry in split_entries(val):
                if not entry:
                    continue
                type_item = QTableWidgetItem("Unicode")
                path_item = QTableWidgetItem(str(entry))
                val_lower = entry.lower()
                if any(dll in val_lower for dll in system_dlls):
                    path_item.setBackground(QColor('#FFEBEE'))
                    path_item.setForeground(QColor('#C62828'))
                    font = path_item.font()
                    font.setBold(True)
                    path_item.setFont(font)
                    path_item.setToolTip('System DLL or sensitive file')
                else:
                    path_item.setBackground(QColor('#E0F7FA'))
                    path_item.setForeground(QColor('#00695C'))
                if len(entry) > 40:
                    path_item.setToolTip(entry)
                self.file_access_table.insertRow(row)
                self.file_access_table.setItem(row, 0, type_item)
                self.file_access_table.setItem(row, 1, path_item)
                row += 1

    def display_anti_vm(self, results):
        # Use a single table with two columns: Source, Indicator
        if hasattr(self, 'anti_vm_table2'):
            self.anti_vm_table2.setRowCount(0)
        else:
            from PyQt5.QtWidgets import QTableWidget
            self.anti_vm_table2 = QTableWidget()
            self.anti_vm_table2.setColumnCount(2)
            self.anti_vm_table2.setHorizontalHeaderLabels(["Source", "Indicator"])
            self.anti_vm_table2.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeToContents)
            self.anti_vm_table2.horizontalHeader().setSectionResizeMode(1, QHeaderView.Stretch)
            self.anti_vm_layout.addWidget(self.anti_vm_table2)
        self.anti_vm_table2.setRowCount(0)
        tricks = results.get('anti_vm_sandbox', [])
        known_tricks = [
            'procexp', 'getsysteminfo', 'getversion', 'createtoolhelp32snapshot',
            'vmware', 'vbox', 'virtualbox', 'sandbox', 'qemu', 'debug', 'wine', 'xen'
        ]
        def split_tricks(entry):
            if isinstance(entry, list):
                return entry
            if isinstance(entry, str):
                if '\n' in entry:
                    return [e.strip() for e in entry.split('\n') if e.strip()]
                if ',' in entry:
                    return [e.strip() for e in entry.split(',') if e.strip()]
                return [entry.strip()]
            return [str(entry)]
        unique_tricks = []
        seen = set()
        for val in tricks:
            for entry in split_tricks(val):
                if entry and entry not in seen:
                    unique_tricks.append(entry)
                    seen.add(entry)
        row = 0
        for entry in unique_tricks:
            # Try to guess the source
            if ':' in entry and any(x in entry for x in ['dll', '.dll']):
                source = 'Import'
            elif any(x in entry.lower() for x in known_tricks):
                source = 'String'
            else:
                source = 'Other'
            source_item = QTableWidgetItem(source)
            indicator_item = QTableWidgetItem(str(entry))
            val_lower = str(entry).lower()
            if any(trick in val_lower for trick in known_tricks):
                indicator_item.setBackground(QColor('#FFEBEE'))
                indicator_item.setForeground(QColor('#C62828'))
                font = indicator_item.font()
                font.setBold(True)
                indicator_item.setFont(font)
                indicator_item.setToolTip('Known anti-VM or sandbox evasion technique')
            else:
                indicator_item.setBackground(QColor('#FFFDE7'))
                indicator_item.setForeground(QColor('#F9A825'))
                indicator_item.setToolTip('Potential anti-VM/sandbox indicator')
            if len(entry) > 40:
                indicator_item.setToolTip(entry)
            self.anti_vm_table2.insertRow(row)
            self.anti_vm_table2.setItem(row, 0, source_item)
            self.anti_vm_table2.setItem(row, 1, indicator_item)
            row += 1

    def display_urls_ips(self, results):
        self.urls_table.setRowCount(0)
        self.ips_table.setRowCount(0)
        urls = results.get('urls', [])
        ips = results.get('ip_addresses', [])
        for row, url in enumerate(urls):
            self.urls_table.insertRow(row)
            self.urls_table.setItem(row, 0, QTableWidgetItem(str(url)))
        for row, ip in enumerate(ips):
            self.ips_table.insertRow(row)
            self.ips_table.setItem(row, 0, QTableWidgetItem(str(ip)))

    def display_payloads(self, results):
        self.payloads_table.setRowCount(0)
        payloads = results.get('payloads', [])
        for row, val in enumerate(payloads):
            self.payloads_table.insertRow(row)
            self.payloads_table.setItem(row, 0, QTableWidgetItem(str(val)))

    def display_extra_analysis(self, results):
        self.extra_analysis_table.setRowCount(0)
        extra = results.get('extra_analysis', {})
        if isinstance(extra, dict):
            for row, (k, v) in enumerate(extra.items()):
                self.extra_analysis_table.insertRow(row)
                self.extra_analysis_table.setItem(row, 0, QTableWidgetItem(str(k)))
                self.extra_analysis_table.setItem(row, 1, QTableWidgetItem(str(v)))

    def display_indicators(self, results):
        indicators = results.get('suspicious_indicators', [])
        if isinstance(indicators, list):
            self.indicators_list.setPlainText('\n'.join(str(i) for i in indicators))
            # Add right-click AI explanation for each indicator
            def context_menu_event(event):
                from PyQt5.QtWidgets import QMenu
                menu = QMenu(self.indicators_list)
                cursor = self.indicators_list.cursorForPosition(event.pos())
                cursor.select(cursor.LineUnderCursor)
                selected_text = cursor.selectedText()
                if selected_text:
                    explain_action = menu.addAction("Explain with AI")
                    action = menu.exec_(self.indicators_list.mapToGlobal(event.pos()))
                    if action == explain_action:
                        self.show_ai_explanation_dialog(selected_text)
            self.indicators_list.setContextMenuPolicy(3)  # Qt.CustomContextMenu
            self.indicators_list.customContextMenuRequested.connect(context_menu_event)
        else:
            self.indicators_list.setPlainText(str(indicators))

# Typical PyQt5 main entry point
if __name__ =="__main__":
    import sys
    app = QApplication(sys.argv)
    window = MalwareAnalysisGUI()
    window.show()
    sys.exit(app.exec_())
